plik = open("dane_obrazki.txt")
maxbitybledne = 0
bityBledne = list()

def czyPoprawny(obrazek): # обрезок содержит список строк и можно использовать побитовый оператор
                            # obraz[i][j]
    for wiersz in obrazek[:-1]: # не учитываем из последней строки, там находятся биты четности
        if wiersz[:-1].count('1') % 2 != int(wiersz[-1]):
            return False
    for i in range(20): # i = 0,1,2,3,4,5,6,7..19
        kolumna = ""
        for j in range(21):  # j = 0,1,2,3,4,5,..20
            kolumna+=obrazek[j][i]
        if kolumna[:-1].count('1')% 2 != int(kolumna[-1]):
            return False
    return True

def czyNaprawialny(obrazek):
    bityKolBleden = 0
    bityWierBledne = 0
    for wiersz in obrazek[:-1]: # не учитываем из последней строки, там находятся биты четности
        if wiersz[:-1].count('1') % 2 != int(wiersz[-1]):
            bityWierBledne+=1
    for i in range(20): # i = 0,1,2,3,4,5,6,7..19
        kolumna = ""
        for j in range(21):  # j = 0,1,2,3,4,5,..20
            kolumna+=obrazek[j][i]
        if kolumna[:-1].count('1')% 2 != int(kolumna[-1]):
           bityKolBleden+=1
    global maxbitybledne
    if maxbitybledne<(bityKolBleden+bityWierBledne):
        maxbitybledne = bityKolBleden+bityWierBledne
    bityBledne.append(bityKolBleden+bityWierBledne)

    if bityWierBledne >1 :
        return False
    if bityKolBleden > 1:
        return False

    return True

def napraw(obrazek):
    """Wejście stanowi plik tekstowy zawierający dane czarnobiałego obrazka zakodowane jaki piksele.
    0 - piksel biały 1 - piksel czarny. 
    Każdy wiersz oraz kolumna zwiera na swoim końcu bit parzystości . 
    Bit parzystości jest równy 0, jeśli ilość jedynek w wierszy (lub w kolumnie dla kolumn) jest parzysta a 
    1 jeśli jest nieparzysta.
    np.
    0 1 1 0 1 1 bit błędny należy zmienić go na przeciwny
    1 1 1 0 1 0
    1 1 1 1 1 1
    0 1 1 0 0 0
    1 1 0 1 1 0
    1 1 0 0 0 - bity parzystości kolumny 
     ^
     |- bity parzystości wiersza
    Napisz funkcje który znajdzie uszkodzone obrazki oraz je naprawi . tzn Jest to obrazek naprawialny ( 
    posiada co najwyżej jeden bit parzystości wiersza i co najwyżej jeden bit parzystości kolumny 
    niepoprawny ) a następnie naprawi te obrazy 
    Wynik ma zawierać obrazek błędny(naprawialny) oraz obrazek poprawiony"""
    wynik = list()

    # Find the incorrect row
    for wiersz in obrazek[:-1]: 
        if wiersz[:-1].count('1') % 2 != int(wiersz[-1]):
            row_index = obrazek.index(wiersz)
            break

    # Find the incorrect column
    for i in range(20): 
        kolumna = ""
        for j in range(21):  
            kolumna+=obrazek[j][i]
        if kolumna[:-1].count('1')% 2 != int(kolumna[-1]):
            col_index = i
            break

    # Correct the incorrect bit
    if row_index != 20:
        wiersz = list(obrazek[row_index])
        if wiersz[col_index] == '0':
            wiersz[col_index] = '1'
        else:
            wiersz[col_index] = '0'
        obrazek[row_index] = "".join(wiersz)

    return obrazek


poprawne = 0
naprawialne = 0
obrazek = list()
for linia in plik:
    wiersz = linia.strip() # удаляем пробелы, например, enter
   # wiersz = wiersz[:-1]  # только данные изображения без бита четности, теперь читаем всю строку данных
    # print(wiersz)
    obrazek.append(wiersz)
    if len(obrazek) == 21: # у нас 21 строка, то есть весь рисунок вместе со строками битов четности
        if czyPoprawny(obrazek):
            poprawne+=1
        elif czyNaprawialny(obrazek):
            naprawialne+=1
            naprawiony = napraw(obrazek)


    if len(obrazek) == 21:  # после 22 строки очищаем изображение, чтобы читать строки следующего изображения
        obrazek = list()

print(poprawne,naprawialne,200-poprawne-naprawialne)
print(maxbitybledne,max(bityBledne))