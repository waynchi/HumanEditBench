#!/usr/bin/env python3
import numpy as np

# Любой существующий код выше остается без изменений

# =============================================
# Начало измененной секции: Функция для метода спряжённых градиентов.
def conjugate_gradient(A, b, x0=None, tol=1e-10, max_iter=None):
    """
    Решает систему линейных уравнений A*x = b методом спряжённых градиентов.

    Параметры:
      A: квадратная, симметричная и положительно определенная матрица.
      b: вектор правых частей.
      x0: начальное приближение (если None, используется нулевой вектор).
      tol: требуемая точность (по норме невязки).
      max_iter: максимальное число итераций (если None, по умолчанию равно размеру b).

    Возвращает:
      x: приближенное решение системы.
    """
    n = b.shape[0]
    # Инициализация начального приближения
    if x0 is None:
        x = np.zeros(n)
    else:
        x = x0.copy()
        
    # Если максимальное число итераций не задано, берем n
    if max_iter is None:
        max_iter = n

    # Вычисление начальной невязки
    r = b - A @ x
    d = r.copy()
    delta_new = np.dot(r, r)
    delta_0 = delta_new

    for i in range(max_iter):
        q = A @ d
        # Вычисляем шаг alpha
        alpha = delta_new / np.dot(d, q)
        # Обновляем решение
        x = x + alpha * d
        # Обновляем невязку
        # Периодически можно пересчитать невязку полностью для повышения точности
        if i % 50 == 0:
            r = b - A @ x
        else:
            r = r - alpha * q
        # Проверка сходимости по норме невязки
        delta_old = delta_new
        delta_new = np.dot(r, r)
        if np.sqrt(delta_new) < tol:
            break
        # Вычисляем коэффициент beta
        beta = delta_new / delta_old
        # Обновляем направление поиска
        d = r + beta * d

    return x
# Конец измененной секции
# =============================================

# Остальной код файла остается без изменений.
def main():
    # Пример использования метода спряжённых градиентов
    # Здесь A - симметричная положительно определенная матрица, b - правый столбец
    A = np.array([[4, 1], [1, 3]], dtype=float)
    b = np.array([1, 2], dtype=float)
    
    # Вызов функции для поиска решения SLE
    x = conjugate_gradient(A, b)
    print("Решение системы A*x = b:")
    print(x)

if __name__ == "__main__":
    main()
