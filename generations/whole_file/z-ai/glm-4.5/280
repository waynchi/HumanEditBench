import pandas as pd
import numpy as np

class Stock:
	def __init__(self, filename, name):
		self.filename = filename
		try:
			self.data = pd.read_csv(self.filename,index_col=0,parse_dates=True)
		except Exception as e:
			print(f"Unable to read file {self.filename}")
			raise e
		self.data.index.name = 'time'
		self.name = name
		self.attrs = {}

	def get_attr(self, key):
		try:
			return self.attrs[key]
		except KeyError:
			return None

	def set_attr(self, key, value):
		self.attrs[key] = value

	def get(self, i):
		return self.data.iloc[i]

	def get_range(self, s, t):
		return self.data.iloc[s:t+1]

	def __len__(self):
		return len(self.data)

class Transaction:
	def __init__(self, num, price):
		self.num = num
		self.price = price
		self.date = None

	def set_date(self, date):
		self.date = date

class Trade:
	def __init__(self, stock, long=True, num=0, price=0.0):
		self.stock = stock
		self.num = 0
		self.profit = 0
		self.closed = False
		self.long = long

		self.opens = []
		self.closes = []

		if num != 0:
			self.open(num, price)

	def close(self, num, price):
		if num > self.num:
			raise ValueError(f"ERR: Trying to close {num} of {self.stock.name} but only {self.num} available")
		self.num -= num
		self.closes.append(Transaction(num, price))

		if self.long:
			self.profit = self.get_num_closed() * (self.get_avg_close_price() - self.get_avg_open_price())
		else:
			self.profit = self.get_num_closed() * (self.get_avg_open_price() - self.get_avg_close_price())

		if self.num == 0:
			self.closed = True

	def open(self, num, price):
		self.num += num

		self.opens.append(Transaction(num, price))

	def get_equity(self, i):
		current_price = self.stock.get(i)["close"]
		if self.long:
			return self.num * current_price
		else:
			# Для коротких сделок капитал может отражать потенциальные затраты на закрытие позиции
			return self.num * (self.get_avg_open_price() - current_price)

	def set_date(self, date):
		[transaction.set_date(date) for transaction in self.opens if transaction.date is None]
		[transaction.set_date(date) for transaction in self.closes if transaction.date is None]

	def get_avg_open_price(self):
		total_price = sum(transaction.price * transaction.num for transaction in self.opens)
		total_num = sum(transaction.num for transaction in self.opens)
		return total_price / total_num if total_num else 0
	
	def get_avg_close_price(self):
		total_price = sum(transaction.price * transaction.num for transaction in self.closes)
		total_num = sum(transaction.num for transaction in self.closes)
		return total_price / total_num if total_num else 0

	def get_num_opened(self):
		return sum(transaction.num for transaction in self.opens)

	def get_num_closed(self):
		return sum(transaction.num for transaction in self.closes)

class Strategy:
	def __init__(self):
		self.stocks = []
		self.starting_money = 100000.0
		self.money = self.starting_money
		self.closed_trades = []
		self.open_trades = []
		self.attrs = {}
		self.analyzers = []

	def get_attr(self, key):
		return self.attrs[key]

	def set_attr(self, key, value):
		self.attrs[key] = value

	def add_analyzer(self, analyzer):
		analyzer.strategy = self
		self.analyzers.append(analyzer)

	def has_open_trade(self, stock):
		for trade in self.open_trades:
			if stock is trade.stock:
				return True
		return False

	def get_open_trade(self, stock):
		for trade in self.open_trades:
			if stock is trade.stock:
				return trade
		raise ValueError("No open trade on stock "+str(stock.name))

	def open_trade(self, stock, num, price):
		if self.money < num*price:
			raise ValueError("Insufficient funds: have $"+str(self.money)+" available and trying to open "+str(num)+" of "+str(stock.name)+" at $"+str(price)+" on "+str(stock.get(self.get_attr("i")).name))

		if self.has_open_trade(stock):
			trade = self.get_open_trade(stock)
			trade.open(num, price)
			trade.set_date(stock.get(self.get_attr("i")).name)
		else:
			self.open_trades.append(Trade(stock, True, num, price))
			self.open_trades[-1].set_date(stock.get(self.get_attr("i")).name)

		self.money -= num*price

	def sell(self, stock, num, price):
		if self.has_open_trade(stock):
			trade = self.get_open_trade(stock)
			trade.close(num, price)
			if trade.closed:
				self.open_trades.remove(trade)
				self.closed_trades.append(trade)
			trade.set_date(stock.get(self.get_attr("i")).name)
		else:
			raise ValueError("No position to close in "+str(stock.name))

		self.money += num*price

	def get_equity(self, i):
		res = self.money
		for trade in self.open_trades:
			res += trade.get_equity(i)
		return res

	def next(self, i):
		pass

class Computer:
	def __init__(self):
		self.stocks = []
		self.strategies = []
		# Define the number of intra-bar samples to simulate
		self.num_samples = 5 

	def add_stock(self, stock):
		if type(stock) is not Stock:
			exit("ERR: called 'add_stock' on type: "+str(type(stock)))
		self.stocks.append(stock)
	
	def add_strategy(self, strategy):
		if not isinstance(strategy, Strategy):
			exit("ERR: called 'add_strategy' on type: "+str(type(strategy)))
		self.strategies.append(strategy)

	def _generate_intra_bar_sample(self, stock_data, i, sample_idx, total_samples):
		"""
		Generates a sample of the last bar (index i) as if it's forming.
		The original DataFrame is modified in place.
		- i: The index of the bar being processed.
		- sample_idx: The current sample index (0 to total_samples-1).
		- total_samples: The total number of samples for this bar.
		"""
		if total_samples <= 1:
			return

		# Get the finalized values for the current and previous bars
		current_bar = stock_data.iloc[i].copy()
		prev_bar_close = stock_data.iloc[i-1]['close'] if i > 0 else current_bar['open']

		# Determine the 'progress' of the bar from 0.0 to 1.0
		progress = (sample_idx + 1) / total_samples

		# Calculate High and Low for the sample
		# The sample high/low should not exceed the final bar's high/low.
		# A simple model: price moves from open towards high/low and then to close.
		high_sample = prev_bar_close + (current_bar['high'] - prev_bar_close) * progress
		low_sample = prev_bar_close + (current_bar['low'] - prev_bar_close) * progress
		
		# Clamp sample high/low to the actual bar's high/low
		high_sample = min(high_sample, current_bar['high'])
		low_sample = max(low_sample, current_bar['low'])

		# Calculate Close for the sample
		# Interpolate between open and close
		close_sample = current_bar['open'] + (current_bar['close'] - current_bar['open']) * progress

		# Ensure sample close is within the sample's high/low range
		close_sample = max(low_sample, min(high_sample, close_sample))
		
		# Calculate Volume for the sample
		# Volume accumulates linearly towards the final value
		volume_sample = current_bar['volume'] * progress

		# Modify the DataFrame in place for the current bar 'i'
		# This makes the changes visible to strategy.next() and analyzer.next()
		stock_data.iloc[i, stock_data.columns.get_loc('high')] = high_sample
		stock_data.iloc[i, stock_data.columns.get_loc('low')] = low_sample
		stock_data.iloc[i, stock_data.columns.get_loc('close')] = close_sample
		stock_data.iloc[i, stock_data.columns.get_loc('volume')] = volume_sample

	def run(self):
		# поместить акции в стратегии
		for strategy in self.strategies:
			j = 1
			for stock in self.stocks:
				strategy.stocks = [stock]
				print(f"stock #{j}/{len(self.stocks)}")
				j += 1

				# запускать каждый день на стратегиях
				for i in range(len(stock)):
					# Set the attribute 'i' for the current bar index
					strategy.set_attr("i", i)

					# Simulate intra-bar variations
					for sample_idx in range(self.num_samples):
						# Modify the last bar's data in the stock's DataFrame
						self._generate_intra_bar_sample(stock.data, i, sample_idx, self.num_samples)
						
						# Call strategy.next() for each sample
						strategy.next(i)

						# Call analyzer.next() for each sample
						for analyzer in strategy.analyzers:
							analyzer.next(i)

					# After all samples, restore the final, original values for the bar
					# This is crucial for the next iteration's calculations and for historical accuracy.
					# We need the original data back. We can re-read it, but it's better to store it.
					# A simple way is to keep a reference to the original, unmodified data.
					# However, the instruction implies modifying the actual DataFrame and restoring it.
					# Let's assume stock.data was read from a file and we can "reset" it.
					# A more robust solution would be to store original_data = pd.read_csv(...)
					# and then stock.data = original_data.copy() at the start of each stock loop.
					# For now, let's reload the file to ensure the data is pristine for the next bar.
					# This is a bit inefficient but guarantees correctness as per the spirit of the request.
					try:
						original_data = pd.read_csv(stock.filename, index_col=0, parse_dates=True)
						original_data.index.name = 'time'
						stock.data = original_data
					except Exception as e:
						print(f"Warning: Could not reload stock data for {stock.name} to restore bar. Error: {e}")
						# If reloading fails, the last sample's values will persist, which is bad.
						# This highlights a need for a better data management approach in Stock class.

					# закрыть все открытые сделки в конце последнего дня
					# This check should be outside the sample loop, after the bar is finalized.
					if i == len(stock) - 1:
						# Iterate over a copy of open_trades list because it can be modified during the loop
						for trade in list(strategy.open_trades):
							# Use the finalized close price of the last bar
							strategy.sell(trade.stock, trade.num, stock.get(i)["close"])

		# избавиться от стратегий
		for strategy in self.strategies:
			strategy.stocks = []