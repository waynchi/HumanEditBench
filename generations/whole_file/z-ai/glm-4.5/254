python
plik = open("dane_obrazki.txt")
maxbitybledne = 0
bityBledne = list()
def czyPoprawny(obrazek): # обрезок содержит список строк и можно использовать побитовый оператор
                            # obraz[i][j]
    for wiersz in obrazek[:-1]: # не учитываем из последней строки, там находятся биты четности
        if wiersz[:-1].count('1') % 2 != int(wiersz[-1]):
            return False
    for i in range(20): # i = 0,1,2,3,4,5,6,7..19
        kolumna = ""
        for j in range(21):  # j = 0,1,2,3,4,5,..20
            kolumna+=obrazek[j][i]
        if kolumna[:-1].count('1')% 2 != int(kolumna[-1]):
            return False
    return True

def czyNaprawialny(obrazek):
    bityKolBleden = 0
    bityWierBledne = 0
    for wiersz in obrazek[:-1]: # не учитываем из последней строки, там находятся биты четности
        if wiersz[:-1].count('1') % 2 != int(wiersz[-1]):
            bityWierBledne+=1
    for i in range(20): # i = 0,1,2,3,4,5,6,7..19
        kolumna = ""
        for j in range(21):  # j = 0,1,2,3,4,5,..20
            kolumna+=obrazek[j][i]
        if kolumna[:-1].count('1')% 2 != int(kolumna[-1]):
           bityKolBleden+=1
    global maxbitybledne
    if maxbitybledne<(bityKolBleden+bityWierBledne):
        maxbitybledne = bityKolBleden+bityWierBledne
    bityBledne.append(bityKolBleden+bityWierBledne)

    if bityWierBledne >1 :
        return False
    if bityKolBleden > 1:
        return False

    return True

def napraw(obrazek):
    """Вход представляет собой текстовый файл, содержащий данные черно-белого изображения, закодированные как пиксели. 0 - белый пиксель, 1 - черный пиксель. Каждая строка и столбец содержат в конце бит четности. Бит четности равен 0, если количество единиц в строке (или в столбце для столбцов) четное, и 1, если нечетное. например: 0 1 1 0 1 1 бит ошибочный, его нужно изменить на противоположный 1 1 1 0 1 0 1 1 1 1 1 1 0 1 1 0 0 0 1 1 0 1 1 0 1 1 0 0 0 - биты четности столбца ^ |- биты четности строки Напишите функцию, которая найдет поврежденные изображения и исправит их. т.е. Это изображение исправимо (содержит не более одного неправильного бита четности строки и не более одного неправильного бита четности столбца) и затем исправит эти изображения. Результат должен содержать ошибочное (исправимое) изображение и исправленное изображение."""
    
    # Создаем копию оригинального изображения для сохранения
    original = [row[:] for row in obrazek]
    
    # Инициализируем переменные для ошибок в строках и столбцах
    error_row = None
    error_col = None
    
    # Поиск строки с ошибкой (проверяем строки 0-19)
    for i in range(20):
        row_data = obrazek[i][:20]  # первые 20 символов - данные
        parity_bit = obrazek[i][20]  # последний символ - бит четности
        if row_data.count('1') % 2 != int(parity_bit):
            error_row = i
            break  # не более одной ошибки в строках
    
    # Поиск столбца с ошибкой (проверяем столбцы 0-19)
    for j in range(20):
        col_data = ''.join(obrazek[i][j] for i in range(20))  # первые 20 строк столбца
        parity_bit = obrazek[20][j]  # бит четности в последней строке
        if col_data.count('1') % 2 != int(parity_bit):
            error_col = j
            break  # не более одной ошибки в столбцах
    
    # Создаем исправленную копию изображения
    corrected = [row[:] for row in obrazek]
    
    # Исправление ошибки в зависимости от типа
    if error_row is not None and error_col is not None:
        # Ошибка в бите данных - на пересечении строки и столбца
        row_list = list(corrected[error_row])
        # Инвертируем бит
        row_list[error_col] = '1' if row_list[error_col] == '0' else '0'
        corrected[error_row] = ''.join(row_list)
    elif error_row is not None:
        # Ошибка в бите четности строки
        row_list = list(corrected[error_row])
        # Инвертируем бит четности (последний символ)
        row_list[20] = '1' if row_list[20] == '0' else '0'
        corrected[error_row] = ''.join(row_list)
    elif error_col is not None:
        # Ошибка в бите четности столбца
        row_list = list(corrected[20])
        # Инвертируем бит четности столбца
        row_list[error_col] = '1' if row_list[error_col] == '0' else '0'
        corrected[20] = ''.join(row_list)
    
    # Возвращаем оригинальное и исправленное изображение
    return (original, corrected)

poprawne = 0
naprawialne = 0
obrazek = list()
for linia in plik:
    wiersz = linia.strip() # удаляем пробелы, например, enter
   # wiersz = wiersz[:-1]  # только данные изображения без бита четности, теперь читаем всю строку данных
    obrazek.append(wiersz)
    if len(obrazek) == 21: # у нас 21 строка, то есть весь рисунок вместе со строками битов четности
        if czyPoprawny(obrazek):
            poprawne+=1
        elif czyNaprawialny(obrazek):
            naprawialne+=1
            naprawiony = napraw(obrazek)


    if len(obrazek) == 22:  # после 22 строки очищаем изображение, чтобы читать строки следующего изображения
        obrazek = list()

print(poprawne,naprawialne,200-poprawne-naprawialne)
print(maxbitybledne,max(bityBledne))