import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.stats import skew

# 定义中位数耦合函数(data):
# 数据 = np.sort(data)  # 对数据进行排序
# n = 数据的长度
# 中位数 = np.median(data)

# # 将数据分为小于中位数和大于中位数的部分
# 左边 = 数据[数据 <= 中位数]
# 右侧 = 数据[数据 >= 中位数]

# # 核函数 h(xi, xj)
# 定义 h(xi, xj):
# 如果 xi != xj:
# 返回 ((xj - 中位数) - (中位数 - xi)) / (xj - xi)
# 返回 0  # 尽管 xi != xj 应该排除这种情况

# # 针对中位数重复情况的特殊核函数
# 定义 special_h(i, j, k):
# 如果 i + j - 1 < k:
# 返回 -1
# 否则如果 i + j - 1 == k:
# 返回 0
# 否则 i + j - 1 > k:
# 返回 1

# # 生成所有可能的 h(xi, xj)
# h_values = []  # h值的列表初始化
# k = len(data[data == median])  # 中位数重复值的数量
# 如果 k > 1:  # 处理具有相同中位数的情况
# “对于 i, xi 在 left 中枚举”
# 对右侧进行枚举的循环
# 如果 xi == xj == 中位数:
# 将 special_h(i, j, k) 添加到 h_values 中
# 否则：
# h_values.append(h(xi, xj))
# 否则：
# 对于左侧的 xi:
# 对右侧的 xj 进行迭代：
# h_values.append(h(xi, xj))

# # 返回所有 h 值的中位数
# 返回 np.median(h_values)
# 需要加速并重写函数 medcouple

def medcouple(data):
    data = np.sort(data)
    n = len(data)
    median = np.median(data)

    # 将数据分为中位数的左侧和右侧
    left = data[data <= median]
    right = data[data >= median]

# 核函数 h(xi, xj)
    def h(xi, xj):
        # 确保输入是标量，并处理相等的情况
        if np.isscalar(xi) and np.isscalar(xj):
            if xi != xj:
                return ((xj - median) - (median - xi)) / (xj - xi)
            return 0
        # 处理数组输入，使用向量化的操作
        # 首先创建一个与xi和xj形状相同的数组，初始为0
        result = np.zeros_like(xi, dtype=float)
        # 找到xi和xj不相等的元素的索引
        not_equal_mask = (xi != xj)
        # 只对这些元素进行计算
        result[not_equal_mask] = ((xj[not_equal_mask] - median) - (median - xi[not_equal_mask])) / (xj[not_equal_mask] - xi[not_equal_mask])
        return result

    # 针对重复中位数情况的特殊核函数
    def special_h(i, j, k):
        # 这个函数现在也处理数组输入
        # 初始结果为0
        result = np.zeros_like(i, dtype=float)
        
        # 条件 1: i + j - 1 < k
        cond1 = (i + j - 1 < k)
        result[cond1] = -1
        
        # 条件 2: i + j - 1 > k
        cond2 = (i + j - 1 > k)
        result[cond2] = 1
        
        # 默认情况 (i + j - 1 == k) 结果为0，无需额外操作
        return result

    # 生成所有可能的 h(xi, xj)
    h_values = []
    k = len(data[data == median])  # 重复中位数的计数

    # 使用numpy广播以提高效率
    if k > 1:
        left_indices = np.arange(len(left))
        right_indices = np.arange(len(right))
        xi, xj = np.meshgrid(left, right, indexing='ij')
        i, j = np.meshgrid(left_indices, right_indices, indexing='ij')
        
        # 调用向量化版本的special_h和h
        special_values = special_h(i, j, k)
        general_values = h(xi, xj)
        
        # 创建一个布尔掩码，判断xi和xj是否都等于中位数
        # 使用np.vectorize或广播比较
        is_median_mask = (xi == median) & (xj == median)
        
        # 使用np.where进行条件选择
        h_matrix = np.where(is_median_mask, special_values, general_values)
    else:
        xi, xj = np.meshgrid(left, right, indexing='ij')
        h_matrix = h(xi, xj)

    # 将矩阵展平并计算h值的中位数
    return np.median(h_matrix.flatten())

def adjusted_boxplot_bounds(data):
    """计算调整后的箱线图边界，考虑偏度调整的围栏。"""
    q1 = np.percentile(data, 25)
    q3 = np.percentile(data, 75)
    iqr = q3 - q1
    _medcouple = medcouple(data)

    if _medcouple > 0:
        lower_fence = q1 - 1.5 * np.exp(-4 * _medcouple) * iqr
        upper_fence = q3 + 1.5 * np.exp(3 * _medcouple) * iqr
    else:
        lower_fence = q1 - 1.5 * np.exp(-3 * _medcouple) * iqr
        upper_fence = q3 + 1.5 * np.exp(4 * _medcouple) * iqr

    return lower_fence, upper_fence

def normalize_column(data):
    """使用调整后的箱线图进行归一化。"""
    lower_fence, upper_fence = adjusted_boxplot_bounds(data)
    print(lower_fence)
    return (data - lower_fence) / (upper_fence - lower_fence)

# 生成数据
np.random.seed(42)
data_normal = np.random.normal(loc=50, scale=10, size=10000)
data_skewed = np.random.exponential(scale=20, size=10000)
data_skewed = np.concatenate([data_skewed[5:], [200, 250, 300, -100, -50]])
data_with_outliers = np.concatenate([data_normal, [150, 160, 170]])

# 归一化
df = pd.DataFrame({
    "Normal": data_normal,
    "Skewed": data_skewed,
    # With_Outliers": data_with_outliers[3:],
})

normalized_df = df.apply(normalize_column)

plt.figure(figsize=(16, 4), dpi=250)

bins = np.linspace(-5, 200, 206)
bin_width = bins[1] - bins[0]  # 一个箱的宽度

for col in df.columns:
    # 绘制原始数据的直方图，使用50个箱子，透明度为0.5，并添加标签为'{col} - Original
    # 计算直方图而不绘制
    hist, _ = np.histogram(df[col], bins=bins)

    # 每个直方图的柱位置
    bin_centers = (bins[:-1] + bins[1:]) / 2

    # 每个数据集的偏移量
    offset = bin_width / 4
    plt.bar(bin_centers - offset, hist, width=bin_width, align='center', alpha=0.2, label=f'{col}')
    plt.legend()
    plt.title(f"Histogram Before Normalization")
plt.xlim(-10, 200)
plt.show()

bins = np.linspace(-2, 2, 101)
bin_width = bins[1] - bins[0]  # 一个bin的宽度


plt.figure(figsize=(16, 4), dpi=250)
for col in normalized_df.columns:
    # plt.hist(normalized_df[col], bins=50, alpha=0.5, label=f'{col} - 归一化')
    hist, _ = np.histogram(normalized_df[col], bins=bins)

    # 每个直方图的柱位置
    bin_centers = (bins[:-1] + bins[1:]) / 2
    # 每个数据集的偏移量
    offset = bin_width / 2
    plt.bar(bin_centers - offset, hist, width=bin_width, align='center', label=f'{col}', alpha=0.2)
    plt.legend()
    plt.title(f"Histogram After Normalization")
plt.show()