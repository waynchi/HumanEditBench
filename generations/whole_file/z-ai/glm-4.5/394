python
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score

def cluster_data(features_transformed, cluster_config, n_clusters=2, clustering_method='kmeans'):
    """Wykonuje klasteryzację danych dla niezależnych zestawów kolumn.

Args:
    features_transformed (pandas.DataFrame): Przekształcony DataFrame z parametrami.
    cluster_config (dict): Słownik konfiguracji klastrowania {nazwa_kolumny_klastra: (kolumna1, kolumna2, ...)}.
    n_clusters (int or dict): Liczba klastrów (int dla wszystkich lub dict per zestaw).
    clustering_method (str): Metoda klasteryzacji ('kmeans').

Returns:
    pandas.DataFrame: DataFrame z dodanymi kolumnami etykiet klastrów."""
    if features_transformed is None:
        print("Сначала выполните преобразование данных (этап 5).")
        return None

    # Obsługa różnych typów n_clusters
    if isinstance(n_clusters, int):
        n_clusters_dict = {key: n_clusters for key in cluster_config.keys()}
    elif isinstance(n_clusters, dict):
        n_clusters_dict = n_clusters
    else:
        raise TypeError("n_clusters musi być liczbą całkowitą lub słownikiem")

    # Przetwarzanie każdej konfiguracji klastrowania
    for cluster_col, feature_cols in cluster_config.items():
        # Sprawdzenie czy kolumny istnieją
        missing_cols = [col for col in feature_cols if col not in features_transformed.columns]
        if missing_cols:
            print(f"Brakujące kolumny dla {cluster_col}: {missing_cols}. Pomijam ten zestaw.")
            continue
            
        # Przygotowanie danych do klastrowania
        features_for_clustering = features_transformed[list(feature_cols)]
        
        if clustering_method == 'kmeans':
            n = n_clusters_dict.get(cluster_col, 2)  # Domyślnie 2 jeśli nie określono
            model = KMeans(n_clusters=n, random_state=42, n_init=10)
            cluster_labels = model.fit_predict(features_for_clustering)
            
            # Ocena jakości klasteryzacji
            if len(np.unique(cluster_labels)) > 1:
                silhouette_avg = silhouette_score(features_for_clustering, cluster_labels)
                print(f"Коэффициент силуэта dla {cluster_col} ({n} klastrów): {silhouette_avg:.4f}")
            else:
                print(f"Невозможно рассчитать коэффициент силуэта dla {cluster_col} (wszystkie punkty w jednym klastrze).")
            
            # Dodanie etykiet do DataFrame
            features_transformed[cluster_col] = cluster_labels
            print(f"Кластеризация wykonana. Etykiety dodane do kolumny '{cluster_col}'.")
        else:
            print(f"Неподдерживаемый метод кластеризации dla {cluster_col}.")
            continue

    return features_transformed

# Wykonywanie klasteryzacji (po etapie 5 i przed etapem 6)
if 'features_transformed' in locals() and features_transformed is not None:
    # Przykładowa konfiguracja klastrowania - użytkownik powinien dostosować do swoich danych
    cluster_config = {
        'Klaster1': ('kolumna1', 'kolumna2'),  # Zastąp rzeczywistymi nazwami kolumn
        'Klaster2': ('kolumna3',)              # Zastąp rzeczywistą nazwą kolumny
    }
    
    # Określenie liczby klastrów (może być wspólna lub per zestaw)
    n_clusters = 3  # Wspólna dla wszystkich zestawów
    # Lub wersja per zestaw:
    # n_clusters = {
    #     'Klaster1': 3,
    #     'Klaster2': 2
    # }
    
    features_transformed = cluster_data(features_transformed, cluster_config, n_clusters)
    
    # Wizualizacja wyników klastrowania
    for cluster_col, feature_cols in cluster_config.items():
        if cluster_col not in features_transformed.columns:
            continue  # Pomiń jeśli klastrowanie się nie powiodło
            
        if len(feature_cols) >= 2:
            plt.figure(figsize=(8, 6))
            plt.scatter(
                features_transformed[feature_cols[0]], 
                features_transformed[feature_cols[1]], 
                c=features_transformed[cluster_col], 
                cmap='viridis'
            )
            plt.xlabel(feature_cols[0])
            plt.ylabel(feature_cols[1])
            plt.title(f'Wyniki klastrowania: {cluster_col}')
            plt.colorbar(label='Numer klastra')
            plt.show()
        else:
            print(f"Brak wystarczającej liczby cech do wizualizacji dla {cluster_col} (wymagane co najmniej 2).")
else:
    print("Сначала выполните этап 5 (Преобразование данных).")