function createTurnState(allyStates, foeStates) {
  // Find current turn based wich group still has units that can act



  let turnNumber = 1;
  let currentTurn = "player"; // Initialize currentTurn

  function getCurrentTurn() {
    return currentTurn;
  }

  function getTurnNumber() {
    return turnNumber;
  }

  function nextTurn() {
    // Determine which group has units that can act
    const allyCanAct = allyStates.some(unit => !unit.hasActed);
    const foeCanAct = foeStates.some(unit => !unit.hasActed);
    
    if (currentTurn === "player") {
      if (foeCanAct) {
        currentTurn = "cpu";
        // CPU logic here (e.g., AI movement and actions)
        allyStates.forEach(unit => unit.hasActed = true);
        foeStates.forEach(unit => unit.hasActed = false);
        cpuTurn();
      } else {
        // If no foe units can act, player continues
        currentTurn = "player";
        foeStates.forEach(unit => unit.hasActed = true);
        allyStates.forEach(unit => unit.hasActed = false);
        turnNumber++;
      }
    } else {
      if (allyCanAct) {
        currentTurn = "player";
        foeStates.forEach(unit => unit.hasActed = true);
        allyStates.forEach(unit => unit.hasActed = false);
        // Don't increment turn number here since it was already incremented when switching back to player
      } else {
        // If no ally units can act, cpu continues  
        currentTurn = "cpu";
        allyStates.forEach(unit => unit.hasActed = true);
        foeStates.forEach(unit => unit.hasActed = false);
        cpuTurn();
      }
    }
  }

  function cpuTurn() {
    // Example CPU behavior (replace with your actual AI logic)
    for (const cpuUnit of foeStates) {
      if (!cpuUnit.hasActed) { // Check if the unit has already acted in this turn
        // Perform CPU actions (e.g., movement, attack)
        // ... your CPU AI logic here ...

        cpuUnit.hasActed = true; // Mark the unit as having acted
      }
    }

    // After all CPU units have acted (or chosen not to), end the CPU turn
    nextTurn(); // Automatically switch back to player's turn
  }  

  return {
    getCurrentTurn,
    getTurnNumber,
    nextTurn
  };
}

export { createTurnState };