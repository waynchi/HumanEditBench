import tkinter as tk
import random
import math

def random_color():
    # Generate bright-ish random colors
    r = random.randint(60, 255)
    g = random.randint(60, 255)
    b = random.randint(60, 255)
    return f"#{r:02x}{g:02x}{b:02x}"

def get_canvas_size(canvas):
    # Robustly get the canvas size even before the window is fully realized
    w = canvas.winfo_width()
    h = canvas.winfo_height()
    if w <= 1 or h <= 1:
        # Fallback to configured or requested size
        try:
            w = int(canvas["width"])
            h = int(canvas["height"])
        except Exception:
            w = canvas.winfo_reqwidth()
            h = canvas.winfo_reqheight()
    return w, h

class Square:
    def __init__(self, canvas, size, x, y):
        self.canvas = canvas
        self.size = size
        self.x = x
        self.y = y
        # Slightly faster speeds to make motion more visible
        self.dx = random.choice([-4, -3, -2, 2, 3, 4])
        self.dy = random.choice([-4, -3, -2, 2, 3, 4])
        self.color = random_color()
        self.square = canvas.create_rectangle(
            x, y, x + size, y + size, fill=self.color, outline="#222", width=1
        )

    def move(self):
        self.x += self.dx
        self.y += self.dy
        self.canvas.move(self.square, self.dx, self.dy)

        # Check boundaries with robust canvas size
        canvas_width, canvas_height = get_canvas_size(self.canvas)

        if (
            self.x <= 0
            or self.x + self.size >= canvas_width
            or self.y <= 0
            or self.y + self.size >= canvas_height
        ):
            # Delete current square
            self.canvas.delete(self.square)
            # Create two new colored squares if size is big enough
            if self.size > 10:
                new_size = self.size / 2
                offset = new_size / 2

                # Spawn near current position so it's visible where it split
                nx1 = max(0, min(canvas_width - new_size, self.x - offset))
                ny1 = max(0, min(canvas_height - new_size, self.y - offset))
                nx2 = max(0, min(canvas_width - new_size, self.x + offset))
                ny2 = max(0, min(canvas_height - new_size, self.y + offset))

                squares.append(Square(self.canvas, new_size, nx1, ny1))
                squares.append(Square(self.canvas, new_size, nx2, ny2))
            return False
        return True

def update():
    global squares
    # Move all squares and remove those that hit boundaries
    squares = [square for square in squares if square.move()]
    root.after(20, update)  # Update every 20ms

# Create main window
root = tk.Tk()
root.title("Splitting Squares")

# Create canvas
canvas = tk.Canvas(root, width=600, height=600, bg="white")
canvas.pack(expand=True, fill="both")

# Create initial square
squares = [Square(canvas, 100, 250, 250)]

# Start animation
update()

# Start main loop
root.mainloop()