from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score
import numpy as np
import matplotlib.pyplot as plt

def cluster_data(features_transformed, clusters_spec, n_clusters=2, clustering_method='kmeans'):
    """
    Выполняет независимую кластеризацию для заданных наборов столбцов.

    Args:
        features_transformed (pandas.DataFrame): Преобразованный DataFrame с параметрами.
        clusters_spec (dict): Словарь вида {'ИмяСтолбцаКластера': ('столбец1', 'столбец2', ...), ...}.
                              Ключ — имя нового столбца с метками кластеров.
                              Значение — последовательность столбцов, по которым проводится кластеризация.
        n_clusters (int): Количество кластеров (применяется ко всем наборам).
        clustering_method (str): Метод кластеризации ('kmeans').

    Returns:
        pandas.DataFrame: DataFrame с добавленными столбцами меток кластеров.
    """
    if features_transformed is None:
        print("Сначала выполните преобразование данных (этап 5).")
        return None

    if not isinstance(clusters_spec, dict) or not clusters_spec:
        print("clusters_spec должен быть непустым словарём вида {'cluster_name': (col1, col2, ...)}.")
        return None

    df = features_transformed.copy()

    for cluster_feature_name, cols in clusters_spec.items():
        # Приведение cols к списку
        if isinstance(cols, str):
            cols = [cols]
        else:
            cols = list(cols)

        # Проверка существования столбцов
        missing = [c for c in cols if c not in df.columns]
        if missing:
            print(f"[{cluster_feature_name}] Пропущенные столбцы: {missing}. Кластеризация для этого набора пропущена.")
            df[cluster_feature_name] = np.nan
            continue

        X = df[cols]

        # Проверка, что все столбцы числовые
        non_numeric = [c for c in cols if not np.issubdtype(X[c].dtype, np.number)]
        if non_numeric:
            print(f"[{cluster_feature_name}] Ненумерные столбцы {non_numeric}. Кластеризация пропущена.")
            df[cluster_feature_name] = np.nan
            continue

        # Обработка пропусков: учитываем только строки без NaN для данного набора столбцов
        valid_mask = X.notna().all(axis=1)
        X_valid = X[valid_mask]

        if len(X_valid) < max(2, n_clusters):
            print(f"[{cluster_feature_name}] Недостаточно валидных наблюдений ({len(X_valid)}) для {n_clusters} кластеров. Пропуск.")
            df[cluster_feature_name] = np.nan
            continue

        if clustering_method == 'kmeans':
            model = KMeans(n_clusters=n_clusters, random_state=42, n_init=10)
            cluster_labels = model.fit_predict(X_valid)

            # Оценка качества кластеризации (коэффициент силуэта)
            if len(np.unique(cluster_labels)) > 1 and len(X_valid) > 1:
                try:
                    silhouette_avg = silhouette_score(X_valid, cluster_labels)
                    print(f"[{cluster_feature_name}] Коэффициент силуэта для {n_clusters} кластеров: {silhouette_avg:.4f}")
                except Exception as e:
                    print(f"[{cluster_feature_name}] Не удалось рассчитать коэффициент силуэта: {e}")
            else:
                print(f"[{cluster_feature_name}] Невозможно рассчитать коэффициент силуэта (все точки в одном кластере).")
        else:
            print(f"[{cluster_feature_name}] Неподдерживаемый метод кластеризации '{clustering_method}'.")
            df[cluster_feature_name] = np.nan
            continue

        # Возвращаем метки в изначальный DataFrame, NaN — для строк с пропусками по признакам набора
        labels_full = np.full(len(df), np.nan)
        labels_full[valid_mask.to_numpy()] = cluster_labels
        df[cluster_feature_name] = labels_full

        print(f"[{cluster_feature_name}] Кластеризация выполнена. Метки кластеров добавлены в столбец '{cluster_feature_name}'.")

    return df

# Выполнение кластеризации (после этапа 5 и до этапа 6)
if 'features_transformed' in locals() and features_transformed is not None:
    # Пример: задайте словарь, где ключ — имя создаваемого столбца с метками кластеров,
    # а значение — кортеж/список столбцов, по которым нужно кластеризовать независимо.
    # Замените 'столбец1', 'столбец2', 'столбец3' на реальные названия ваших признаков.
    clusters_spec = {
        'Кластер1': ('столбец1', 'столбец2'),
        'Кластер2': ('столбец3',)
    }

    n_clusters = 3  # Количество кластеров (подберите оптимальное значение)
    features_transformed = cluster_data(features_transformed, clusters_spec, n_clusters)

    # Визуализация кластеров отдельно для каждого набора (если есть >= 2 числовых признаков)
    for cluster_col, cols in clusters_spec.items():
        cols = [cols] if isinstance(cols, str) else list(cols)
        # Оставляем только числовые столбцы из набора
        numeric_cols = [c for c in cols if c in features_transformed.columns and np.issubdtype(features_transformed[c].dtype, np.number)]

        if len(numeric_cols) >= 2 and cluster_col in features_transformed.columns:
            plt.figure(figsize=(8, 6))
            subset = features_transformed[numeric_cols[:2]]
            mask_valid = subset.notna().all(axis=1) & features_transformed[cluster_col].notna()
            if mask_valid.any():
                plt.scatter(
                    subset.loc[mask_valid, numeric_cols[0]],
                    subset.loc[mask_valid, numeric_cols[1]],
                    c=features_transformed.loc[mask_valid, cluster_col],
                    cmap='viridis'
                )
                plt.xlabel(numeric_cols[0])
                plt.ylabel(numeric_cols[1])
                plt.title(f'Результаты кластеризации: {cluster_col}')
                plt.colorbar(label='Номер кластера')
                plt.show()
            else:
                print(f"[{cluster_col}] Недостаточно валидных точек для визуализации.")
        else:
            print(f"[{cluster_col}] Недостаточно числовых признаков для визуализации на плоскости (нужно >= 2).")
else:
    print("Сначала выполните этап 5 (Преобразование данных).")