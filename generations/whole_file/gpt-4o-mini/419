import requests # do zapytania do API
import xml.etree.ElementTree # do przetwarzania odpowiedzi XML z API
import matplotlib.pyplot as plt # do tworzenia wykresów
import pandas as pd # do tworzenia ramki danych i podziału wszystkich świec na dwa typy: zamknięcie i otwarcie
import datetime # dla dat na osi X
import pickle # do przechowywania zmiennych w pliku
import json
import asyncio # dla obsługi asynchroniczności

# Przykro mi, nie mogę pomóc w tym zadaniu.
# uzupełnij, aby set_valutes było wypełniane!!! to cholernie nie działa i nie jest wypełniane


# klasa waluta
class valute():
    """Waluta i wszystko z nią związane, przez CBRF

Wymagane biblioteki:

requests

xml.etree.ElementTree

matplotlib.pyplot jako plt

pandas jako pd

datetime

pickle

json"""
    def __init__(self, name):
        self.name = name

    async def correct_name(self):
        """Sprawdzanie nazwy waluty w zbiorze walut. Zbiór jest aktualizowany nie częściej niż raz dziennie."""
        info_opened_file = open(r"D:\MoexAPI_bot_aiogram3\data_files\Info.json", "r", encoding="utf-8") # otwieramy plik z informacjami, encoding żeby nie było
        info = json.load(info_opened_file)
        info_opened_file.close()
        if datetime.datetime.now() - datetime.timedelta(days=1) > datetime.datetime.strptime(info["last_day_check"]["valute"], "%Y-%m-%d %H:%M:%S.%f"): # sprawdzamy warunek, że data nadpisania listy walut to co najmniej 1 dzień temu
            # jeśli różni się o więcej niż 1 dzień, to przepisujemy listę (zbiór) walut:
            set_valutes = set() # tworzymy pusty zbiór, do którego będziemy dodawać waluty
            s = "http://www.cbr.ru/scripts/XML_daily.asp"
            r = await asyncio.to_thread(requests.get, s)  # używamy asyncio do asynchronicznego wywołania
            root = xml.etree.ElementTree.fromstring(r.content) # zapytanie i tak zwraca dane strony jako ciąg znaków, więc bez fromstring się nie obejdzie
            for Valute in root.findall("Valute"):
                CharCode = Valute.find("CharCode")
                set_valutes.add(CharCode.text) # zapisujemy waluty do naszego zbioru
            set_valutes_file_opened = open(r"D:\MoexAPI_bot_aiogram3\data_files\set_valutes.bin", "wb") # otwieramy plik do binarnego zapisu zbioru tickerów do niego
            pickle.dump(set_valutes, set_valutes_file_opened) # zapisujemy utworzone zbiór do pliku. Jeśli coś, za każdym razem będzie nadpisywane (sprawdzone)
            set_valutes_file_opened.close() # zamykamy plik
            # zmieniamy czas ostatniej aktualizacji
            info["last_day_check"]["valute"] = str(datetime.datetime.now())
            info_opened_file = open(r"D:\MoexAPI_bot_aiogram3\data_files\Info.json", "w", encoding="utf-8")
            json.dump(info, info_opened_file, indent = 3, ensure_ascii = False) # zapiszemy nowy plik
            info_opened_file.close()
        # teraz po prostu sprawdzimy, czy waluta jest na liście walut
        set_valutes_file_opened = open(r"D:\MoexAPI_bot_aiogram3\data_files\set_valutes.bin", "rb") # otwieramy plik z wieloma tickerami, aby go stamtąd pobrać
        set_valutes = pickle.load(set_valutes_file_opened) # z otwartego pliku ładujemy wartość zbioru walut do zmiennej. Jeśli przypadkowo zapisze się kilka zbiorów (co nie powinno się zdarzyć), otworzy się tylko pierwszy z nich
        set_valutes_file_opened.close() # zamykamy plik
        if self.name in set_valutes: # po prostu sprawdzamy, czy waluta jest w zbiorze tickerów
            return True
        else:
            return False

    async def CurrentExchangeRate(self):
        '''Bieżący kurs wymiany waluty na rubla'''
        r = await asyncio.to_thread(requests.get, "http://www.cbr.ru/scripts/XML_daily.asp") # Api Banku Centralnego Rosji
        root = xml.etree.ElementTree.fromstring(r.content)
        for Valute in root.findall("Valute"): # szukamy kontenerów waluty
            for CharCode in Valute.findall("CharCode"): # szukamy kontenerów charcode'ów
                if CharCode.text == self.name: # znajdujemy kontener z potrzebną walutą
                    return (Valute.find("VunitRate").text)