import xml.etree.ElementTree  # для обработки xml-ответа API
import matplotlib.pyplot as plt  # для построения графиков
import pandas as pd  # для создания датафрейма и разделения всех свечей на два типа: close и open
import datetime  # для дат по оси иксов
import pickle  # для хранения переменных в файле
import json  # для работы с датабазой
import aiofiles  # асинхронная работа с файлами
import aiohttp  # асинхронные http-запросы
from typing import List
from matplotlib.axes import Axes  # для удобства отображения


# установим стандартный словарь теханализа. Будем использовать его для анализа callback запросов
# в рутере построения графика (так как там неудобно доставать tick_inp)
standart_tech_dict = {
    "value": {"use": False, "has_periods": False, "need_graph_space": True},
    "sma":   {"use": False, "has_periods": True,  "periods": [], "need_graph_space": False},
    "ema":   {"use": False, "has_periods": True,  "periods": [], "need_graph_space": False}
}

# нет проблем с инструментами теханализа и пустыми днями (без торгов),
# тк дни без торгов в датафрейме не нули, а просто не существуют.
# Поэтому они не портят значения индикаторов
# класс тикер, методы график и тек. цена
class ticker():
    """Тикер акции и всё с ним связанное, через MoexApi"""
    def __init__(self, name: str):
        """self.name - имя тикера
        self.tech_dict - словарь теханализа"""
        self.name = name
        """Имя тикера, то есть сам по себе тикер"""
        # в принципе тут можно менять общие для всех юзеров настройки по умолчанию.
        # Потенциально надо через это реализовать кастомные инструменты теханализа
        self.tech_dict = standart_tech_dict
        """Словарь реализованных опций теханализа. Имеет вид
        {"sma": {"use": True, "periods": [20, 50], "need_graph_space": False},
         "rsi": {"use": True, "periods": [10], "need_graph_space": True}}
        Где use отвечает за использование, period - список периодов, по которым будут считаться значения,
        need_graph_space за то, требует ли осциллятор доп места на графике.
        Изначально все use имеют значение False, а списки периодов пусты.

        При реализации нового инструмента теханализа достаточно дописать его в self.tech_dict.
        При этом функцию, соответствующую этому инструменту важно назвать также,
        как и сам инструмент в словаре. А её аргументы - self и ax (редактируемый/заполняемый график).
        Доп графики инструментов теханализа, которые их требуют, будут отображаться в таком же порядке,
        в котором инструменты располагаются в словаре. Также в этом порядке будут высвечиваться
        кнопки в боте и уже выбранные инструменты теханализа."""
    async def correct_name(self):
        """Проверка имени тикера на наличие в множестве тикеров.
        Множество обновляется не чаще раза в день"""
        async with aiofiles.open(r"D:\MoexAPI_bot_aiogram3\data_files\Info.json", "r", encoding="utf-8") as info_opened_file:
            info = json.loads(await info_opened_file.read())
        if datetime.datetime.now() - datetime.timedelta(days=1) > datetime.datetime.strptime(
                info["last_day_check"]["ticker"], "%Y-%m-%d %H:%M:%S.%f"):  # проверяем, что
            # дата перезаписи списка тикеров это хотя бы 1 день назад
            set_tickers = set()
            s = "https://iss.moex.com/iss/engines/stock/markets/shares/boards/TQBR/securities.xml?iss.meta=off"
            async with aiohttp.ClientSession() as session:  # асинхронно берём данные с api moex
                async with session.get(s) as response:
                    root = xml.etree.ElementTree.fromstring(await response.text())
            for data in root.findall("data"):
                if data.get("id") == "securities":
                    rows = data.find("rows")
                    for row in rows.findall("row"):
                        set_tickers.add(row.get("SECID"))
            async with aiofiles.open(r"D:\MoexAPI_bot_aiogram3\data_files\set_tickers.bin", "wb") as set_tickers_file_opened:
                await set_tickers_file_opened.write(pickle.dumps(set_tickers))
            info["last_day_check"]["ticker"] = str(datetime.datetime.now())
            async with aiofiles.open(r"D:\MoexAPI_bot_aiogram3\data_files\Info.json", "w", encoding="utf-8") as info_opened_file:
                await info_opened_file.write(json.dumps(info, indent=3, ensure_ascii=False))
        async with aiofiles.open(r"D:\MoexAPI_bot_aiogram3\data_files\set_tickers.bin", "rb") as set_tickers_file_opened:
            set_tickers = pickle.loads(await set_tickers_file_opened.read())
        return self.name in set_tickers

    async def CurrentPrice(self):
        """Текущая цена по этому тикеру"""
        s = ("https://iss.moex.com/iss/engines/stock/markets/shares/boards/TQBR/"
             f"securities/{self.name}.xml?iss.meta=off")
        import requests  # синхронный запрос к API moex
        response = requests.get(s)
        root = xml.etree.ElementTree.fromstring(response.text)
        for data in root.findall("data"):
            if data.get("id") == "marketdata":
                rows = data.find("rows")
                row = rows.find("row")
                return row.get("LAST")

    async def candles(self, candles_name: str, timeframe: str, start: str, end: str):
        """Лист свечей для этого тикера
        candles_name - необходимая составляющая свечей: open, close, high, low, value, volume, begin, end
        timeframe - таймфрейм: 1 - 1 мин, 10 - 10 мин, 60 - 1ч, 24 - 1д, 7 - 1н, 31 - 1мес, 4 - 4мес
        start, end - начало и конец периода, формат ГГГГ-ММ-ДД ЧЧ:ММ:СС
        """
        s = ("https://iss.moex.com/iss/engines/stock/markets/shares/boards/TQBR/"
             f"securities/{self.name}/candles.xml?iss.meta=off"
             f"&interval={timeframe}&till={end}&from={start}")
        import requests  # синхронный запрос к API moex
        response = requests.get(s)
        root = xml.etree.ElementTree.fromstring(response.text)
        candles = root.find("data")
        rows = candles.find("rows")
        listcandles = []
        if candles_name in ("begin", "end"):
            for row in rows.findall("row"):
                dt = row.get(candles_name)
                dt_obj = datetime.datetime(
                    int(dt[0:4]), int(dt[5:7]), int(dt[8:10]),
                    int(dt[11:13]), int(dt[14:16]), int(dt[17:]))
                listcandles.append(dt_obj)
        else:
            for row in rows.findall("row"):
                listcandles.append(float(row.get(candles_name)))
        return listcandles

    def setattr_candles_dataframe(self, timeframe=str("24"), start=str(""), end=str("")):
        """Создаёт датафрйм свечей с соответствующим timeframe, start и end и помещает в self.candles_dataframe"""
        candles_dataframe = pd.DataFrame({
            "open":  self.candles("open", timeframe, start, end),
            "close": self.candles("close", timeframe, start, end),
            "high":  self.candles("high", timeframe, start, end),
            "low":   self.candles("low", timeframe, start, end),
            "value": self.candles("value", timeframe, start, end),
            "begin": self.candles("begin", timeframe, start, end)
        })
        setattr(self, "candles_dataframe", candles_dataframe)

    def graphic(self, timeframe=str("24"), start=str(""), end=str(""), user_id=int(1124123332)):
        """Возвращает открытый свечной график цены от времени и сохраняет его в файл для user_id"""
        self.setattr_candles_dataframe(timeframe, start, end)
        up = self.candles_dataframe[self.candles_dataframe.close >= self.candles_dataframe.open]
        down = self.candles_dataframe[self.candles_dataframe.close <  self.candles_dataframe.open]
        setattr(self, "up", up)
        setattr(self, "down", down)

        # Вычисляем ширины свечей
        if timeframe == "1":
            width_big = 1/24/60
        elif timeframe == "10":
            width_big = 1/24/6
        elif timeframe == "60":
            width_big = 1/24
        elif timeframe == "24":
            width_big = 1
        elif timeframe == "7":
            width_big = 7
        elif timeframe == "31":
            width_big = 30
        elif timeframe == "4":
            width_big = 90
        else:
            width_big = 0
        width_small = width_big / 10
        setattr(self, "width_big", width_big)
        setattr(self, "width_small", width_small)

        # Считаем, сколько доп. графиков нужно
        number_of_additional_graphics = sum(
            1 for tech in self.tech_dict
            if self.tech_dict[tech]["use"] and self.tech_dict[tech]["need_graph_space"]
        )

        if number_of_additional_graphics:
            height_ratios = [10 - number_of_additional_graphics] + [1] * number_of_additional_graphics
            fig, axs = plt.subplots(
                nrows=1 + number_of_additional_graphics,
                ncols=1,
                sharex=True,
                height_ratios=height_ratios
            )
            axs: List[Axes]
            plt.suptitle(self.name, fontsize=15)
            axs[0].grid(True)
            # рисуем свечи
            axs[0].bar(
                x=up.begin, height=up.close - up.open,
                width=width_big, bottom=up.open, color="green"
            )
            axs[0].bar(
                x=up.begin, height=up.high - up.close,
                width=width_small, bottom=up.close, color="green"
            )
            axs[0].bar(
                x=up.begin, height=up.open - up.low,
                width=width_small, bottom=up.low, color="green"
            )
            axs[0].bar(
                x=down.begin, height=down.open - down.close,
                width=width_big, bottom=down.close, color="red"
            )
            axs[0].bar(
                x=down.begin, height=down.high - down.open,
                width=width_small, bottom=down.open, color="red"
            )
            axs[0].bar(
                x=down.begin, height=down.close - down.low,
                width=width_small, bottom=down.low, color="red"
            )
            # добавляем теханализ
            idx = 1
            for tech in self.tech_dict:
                if self.tech_dict[tech]["use"] and self.tech_dict[tech]["need_graph_space"]:
                    ax = axs[idx]
                    ax.grid(True)
                    getattr(self, tech)(ax)
                    idx += 1
                elif self.tech_dict[tech]["use"]:
                    getattr(self, tech)(axs[0])
        else:
            fig = plt.figure()
            plt.title(self.name, fontsize=15)
            ax = fig.add_subplot()
            ax.grid(True)
            ax.bar(
                x=up.begin, height=up.close - up.open,
                width=width_big, bottom=up.open, color="green"
            )
            ax.bar(
                x=up.begin, height=up.high - up.close,
                width=width_small, bottom=up.close, color="green"
            )
            ax.bar(
                x=up.begin, height=up.open - up.low,
                width=width_small, bottom=up.low, color="green"
            )
            ax.bar(
                x=down.begin, height=down.open - down.close,
                width=width_big, bottom=down.close, color="red"
            )
            ax.bar(
                x=down.begin, height=down.high - down.open,
                width=width_small, bottom=down.open, color="red"
            )
            ax.bar(
                x=down.begin, height=down.close - down.low,
                width=width_small, bottom=down.low, color="red"
            )
            for tech in self.tech_dict:
                if self.tech_dict[tech]["use"] and not self.tech_dict[tech]["need_graph_space"]:
                    getattr(self, tech)(ax)

        fig.savefig(r"D:\MoexAPI_bot_aiogram3\data_files\graph_for_" + str(user_id) + ".png")
        plt.close(fig)
        return True

    def sma(self, ax):
        for period in self.tech_dict["sma"]["periods"]:
            if period <= len(self.candles_dataframe.begin):
                sma_list = [sum(self.candles_dataframe.close[0:period]) / period]
                for i in range(period, len(self.candles_dataframe.begin)):
                    sma_list.append(
                        sma_list[i - period] +
                        (self.candles_dataframe.close[i] - self.candles_dataframe.close[i - period]) / period
                    )
                ax.plot(self.candles_dataframe.begin[period - 1:], sma_list)

    def ema(self, ax):
        for period in self.tech_dict["ema"]["periods"]:
            if period <= len(self.candles_dataframe.begin):
                ema_list = [sum(self.candles_dataframe.close[0:period]) / period]
                for i in range(period, len(self.candles_dataframe.begin)):
                    ema_list.append(
                        ((period - 1) * ema_list[i - period] + 2 * self.candles_dataframe.close[i]) / (period + 1)
                    )
                ax.plot(self.candles_dataframe.begin[period - 1:], ema_list)

    def value(self, ax):
        ax.bar(x=self.up.begin, height=self.up.value, width=self.width_big, color="green")
        ax.bar(x=self.down.begin, height=self.down.value, width=self.width_big, color="red")
        ax.set_title("Value", fontsize=7)


"""
Тесты
"""

"""
beb = ticker("SBER")
beb.setattr_candles_dataframe("24", "2024-01-01", "2024-01-07")
print(beb.candles_dataframe)
"""

"""
beb.tech_dict["value"]["use"] = True
beb.graphic("24", "2024-01-01", "2024-10-01")
plt.show()
"""

"""
beb = ticker("SBER")
beb.tech_dict["sma"]["use"] = True
beb.tech_dict["sma"]["periods"] = [20, 10]
beb.tech_dict["ema"]["use"] = True
beb.tech_dict["ema"]["periods"] = [150, 250]
beb.tech_dict["value"]["use"] = True
beb.graphic("24", "2024-01-01", "2024-05-01")
"""

**Изменения в сравнении с оригиналом:**
- В методах `CurrentPrice` и `candles` заменена асинхронная часть с `aiohttp` на синхронный запрос через `requests.get()`.  
- Остальной код и структура класса оставлены без изменений.