◁think▷Okay, let me try to figure out what the user wants. The instruction is "add the option to delete the whole directory," and they pointed to the clear_directory function. The original function clears all contents but leaves the directory itself. The user probably wants an option to delete the entire directory instead of just its contents.

Looking at the current code for clear_directory, the function checks if the directory exists. If not, it creates it. Then, it iterates through each item in the directory, deleting files and subdirectories. So, if the user wants to delete the entire directory, maybe we need to add a parameter, like delete_directory, which when True, removes the directory itself instead of clearing its contents.

Wait, how can we do that? The existing code is designed to clear the directory. So maybe modifying the function to have an optional flag. If the flag is set, then after clearing, we delete the directory. Alternatively, have a parameter that allows specifying whether to delete the directory or just its contents.

Let me think about the original code. The first thing is, if the directory doesn't exist, they create it. But if the user wants to delete the entire directory, then when delete=True, we should check if the directory exists and then remove it, rather than creating it if it doesn't. Wait, but the original function's docstring says it "Creates the directory if it doesn't exist." So if the user wants to delete the directory, that part might conflict. Maybe we need to adjust the logic.

Wait, the original code first checks if the directory exists. If not, creates it. Then proceeds to delete all contents. But if the user wants to delete the entire directory, then when delete_directory is True, instead of creating the directory if it doesn't exist, we should just remove it entirely. Wait, but how to handle the case where delete_directory is True and the directory exists. Then, we would remove it. If it doesn't exist, then maybe do nothing. So modifying the function to take an optional parameter delete_directory=False. If delete_directory is True, then we delete the entire directory instead of clearing its contents.

But wait, the original function's purpose is to clear the directory. So adding the option to delete it would be an enhancement. Let me adjust the code:

def clear_directory(directory, delete_directory=False):
    if delete_directory:
        if os.path.exists(directory):
            shutil.rmtree(directory)
            print(f"Deleted directory: {directory}")
        else:
            print(f"Directory '{directory}' does not exist.")
        return
    else:
        proceed as before...

Wait, but the original code handles the case where the directory doesn't exist by creating it. So if delete_directory is True and the directory doesn't exist, then we don't need to create it. So modifying the code:

The original code:

def clear_directory(directory):
    if not os.path.exists(directory):
        os.makedirs(directory)
        print(f"Directory '{directory}' created.")
        return
    for item in os.listdir(directory):
        ... delete items ...

But if add a delete option, perhaps:

def clear_directory(directory, delete_directory=False):
    if delete_directory:
        if os.path.exists(directory):
            shutil.rmtree(directory)
            print(f"Deleted directory: {directory}")
        else:
            print(f"Directory '{directory}' does not exist.")
        return
    if not os.path.exists(directory):
        os.makedirs(directory)
        print(f"Directory '{directory}' created.")
        return
    ... rest of the code ...

But wait, the user's instruction is to "add the option to delete the whole directory". So maybe they want a flag that, when set, removes the entire directory without just cleaning it. So modifying the clear_directory function to include a parameter that allows this.

So here's how I can adjust the code. Add a parameter 'delete_root' (or similar) which is a boolean. If it's True, then instead of cleaning the directory, we delete it.

Wait, the original function is called 'clear_directory', which implies it empties the directory. The user wants the option to delete the entire directory. So changing the function to handle both cases.

So the modified code would be:

def clear_directory(directory, delete_directory=False):
    """
    Clears all files and subdirectories within a given directory. Creates the directory if it doesn't exist.
    If delete_directory is True, deletes the entire directory and its contents.

    Args:
        directory (str): The path to the directory to clear.
        delete_directory (bool): If True, deletes the directory itself. Default is False.

    Raises:
        OSError: If any error occurs during file or directory removal. Provides details about the failure.
    """
    if delete_directory:
        if os.path.exists(directory):
            try:
                shutil.rmtree(directory)
                print(f"Deleted directory: {directory}")
            except OSError as e:
                print(f"Failed to delete directory '{directory}'. Reason: {e}")
        else:
            print(f"Directory '{directory}' does not exist.")
        return

    if not os.path.exists(directory):
        os.makedirs(directory)
        print(f"Directory '{directory}' created.")
        return

    for item in os.listdir(directory):
        item_path = os.path.join(directory, item)
        try:
            if os.path.isdir(item_path):
                shutil.rmtree(item_path)
                print(f"Removed directory: {item_path}")
            else:
                os.remove(item_path)
                print(f"Removed file: {item_path}")
        except OSError as e:
            print(f"Failed to delete '{item_path}'. Reason: {e}")

But wait, the user's original code uses the function clear_directory. So modifying the parameters. Now, the function has a new parameter delete_directory=False. When called with that as True, it deletes the directory instead of clearing it.

So the user can call clear_directory(directory, delete_directory=True) to delete the entire directory. Otherwise, it behaves as before, clearing the contents and creating if not exists.

This modification adds the functionality requested. Now, in the existing code, the function would remain compatible with existing calls, but allows the new behavior when the parameter is set.

So the main changes are adding the delete_directory parameter, and adding the code to delete the directory if the flag is set. Also, in the docstring, need to update it to mention the new parameter.

Looking at the original code:

The original code's docstring says:

    Clears all files and subdirectories within a given directory.  Creates the directory if it doesn't exist.

    Args:
        directory (str): The path to the directory to clear.

    Raises:
        OSError: If any error occurs during file or directory removal.  Provides details about the failure.
    Example:
        clear_directory('/path/to/my/directory')

So updating the docstring to include the new parameter.

So the modified docstring would be:

    Clears all files and subdirectories within a given directory. Creates the directory if it doesn't exist.
    If delete_directory is True, deletes the entire directory and its contents.

    Args:
        directory (str): The path to the directory to clear.
        delete_directory (bool, optional): If True, delete the directory itself. Defaults to False.

    Raises:
        OSError: If any error occurs during file or directory removal. Provides details about the failure.
    Example:
        clear_directory('/path/to/my/directory', delete_directory=True)

But wait, the example in the docstring should be modified to show the new parameter, but the existing example might still be valid. So maybe:

    Example:
        clear_directory('/path/to/my/directory')  # Clears contents
        clear_directory('/path/to/my/directory', delete_directory=True)  # Deletes directory

So the docstring needs to be updated to include the new parameter and example.

Now, applying these changes to the code:

Original code:

def clear_directory(directory):
    """
    Clears all files and subdirectories within a given directory.  Creates the directory if it doesn't exist.

    Args:
        directory (str): The path to the directory to clear.

    Raises:
        OSError: If any error occurs during file or directory removal.  Provides details about the failure.
    Example:
        clear_directory('/path/to/my/directory')
    """
    if not os.path.exists(directory):
        os.makedirs(directory)
        print(f"Directory '{directory}' created.")
        return
    for item in os.listdir(directory):
        item_path = os.path.join(directory, item)
        try:
            if os.path.isdir(item_path):
                shutil.rmtree(item_path)
                print(f"Removed directory: {item_path}")
            else:
                os.remove(item_path)
                print(f"Removed file: {item_path}")
        except OSError as e:
            print(f"Failed to delete '{item_path}'. Reason: {e}")

Modified code:

def clear_directory(directory, delete_directory=False):
    """
    Clears all files and subdirectories within a given directory. Creates the directory if it doesn't exist.
    If delete_directory is True, deletes the entire directory and its contents.

    Args:
        directory (str): The path to the directory to clear.
        delete_directory (bool, optional): If True, delete the directory itself. Defaults to False.

    Raises:
        OSError: If any error occurs during file or directory removal. Provides details about the failure.
    Example:
        clear_directory('/path/to/my/directory')  # Clears contents
        clear_directory('/path/to/my/directory', delete_directory=True)  # Deletes directory
    """
    if delete_directory:
        if os.path.exists(directory):
            try:
                shutil.rmtree(directory)
                print(f"Deleted directory: {directory}")
            except OSError as e:
                print(f"Failed to delete directory '{directory}'. Reason: {e}")
        else:
            print(f"Directory '{directory}' does not exist.")
        return

    if not os.path.exists(directory):
        os.makedirs(directory)
        print(f"Directory '{directory}' created.")
        return

    for item in os.listdir(directory):
        item_path = os.path.join(directory, item)
        try:
            if os.path.isdir(item_path):
                shutil.rmtree(item_path)
                print(f"Removed directory: {item_path}")
            else:
                os.remove(item_path)
                print(f"Removed file: {item_path}")
        except OSError as e:
            print(f"Failed to delete '{item_path}'. Reason: {e}")

So the changes are:

1. Added a parameter delete_directory=False to the function definition.
2. Added the condition to check if delete_directory is True. If yes, delete the directory using shutil.rmtree.
3. Updated the docstring to include the new parameter and example.
4. Inside the delete_directory condition, added a check if the directory exists, then delete it. If it doesn't exist, print a message.
5. The rest of the code remains the same for the case when delete_directory is False.

Now, inserting this modified code back into the user's original code. The user's code is split into multiple functions. The clear_directory function is the one being modified. So the entire code block that was originally:

def clear_directory(directory):
    """
    Clears all files and subdirectories within a given directory.  Creates the directory if it doesn't exist.

    Args:
        directory (str): The path to the directory to clear.

    Raises:
        OSError: If any error occurs during file or directory removal.  Provides details about the failure.
    Example:
        clear_directory('/path/to/my/directory')
    """
    if not os.path.exists(directory):
        os.makedirs(directory)
        print(f"Directory '{directory}' created.")
        return
    for item in os.listdir(directory):
        item_path = os.path.join(directory, item)
        try:
            if os.path.isdir(item_path):
                shutil.rmtree(item_path)
                print(f"Removed directory: {item_path}")
            else:
                os.remove(item_path)
                print(f"Removed file: {item_path}")
        except OSError as e:
            print(f"Failed to delete '{item_path}'. Reason: {e}")

Is replaced with the modified code.

So the entire Python code file would now have:

import os
import shutil

from transformers import AutoModelForCausalLM
from peft import PeftModel

from dotenv import load_dotenv

import pickle
import torch
import json

load_dotenv()

DATA_SAVE_PATH = os.getenv("DATA_SAVE_PATH")
MODEL_PATH = os.getenv("MODEL_PATH")


def save_log_to_file(log_history, file_path, append_latest_only=False):
    """
    Saves the log history to a JSON file.
    If the file already exists, it appends to it.

    Parameters:
    - log_history: List of log entries (each entry is a dict).
    - file_path: Path to the file where logs will be saved.
    - append_latest_only: If True, only the latest log entry is appended.
    """
    # Initialize current_logs
    current_logs = []

    # If the file exists, load the current logs and append to them
    if os.path.exists(file_path):
        try:
            with open(file_path, "r") as f:
                content = f.read().strip()
                if content:
                    current_logs = json.loads(content)
                else:
                    current_logs = []
        except json.JSONDecodeError:
            print(f"Warning: {file_path} contains invalid JSON. Overwriting file.")
            current_logs = []
        except Exception as e:
            print(f"An error occurred while reading {file_path}: {e}")
            current_logs = []
    else:
        # File does not exist; current_logs remains an empty list
        pass

    # Decide whether to append the entire log history or just the latest entry
    if append_latest_only and log_history:
        # Append only the most recent epoch log
        current_logs.append(log_history[-1])
    else:
        # Append the entire log history
        current_logs.extend(log_history)

    # Save the updated log history
    try:
        with open(file_path, "w") as f:
            json.dump(current_logs, f, indent=4)
    except Exception as e:
        print(f"An error occurred while writing to {file_path}: {e}")

def clear_directory(directory, delete_directory=False):
    """
    Clears all files and subdirectories within a given directory. Creates the directory if it doesn't exist.
    If delete_directory is True, deletes the entire directory and its contents.

    Args:
        directory (str): The path to the directory to clear.
        delete_directory (bool, optional): If True, delete the directory itself. Defaults to False.

    Raises:
        OSError: If any error occurs during file or directory removal. Provides details about the failure.
    Example:
        clear_directory('/path/to/my/directory')  # Clears contents
        clear_directory('/path/to/my/directory', delete_directory=True)  # Deletes directory
    """
    if delete_directory:
        if os.path.exists(directory):
            try:
                shutil.rmtree(directory)
                print(f"Deleted directory: {directory}")
            except OSError as e:
                print(f"Failed to delete directory '{directory}'. Reason: {e}")
        else:
            print(f"Directory '{directory}' does not exist.")
        return

    if not os.path.exists(directory):
        os.makedirs(directory)
        print(f"Directory '{directory}' created.")
        return

    for item in os.listdir(directory):
        item_path = os.path.join(directory, item)
        try:
            if os.path.isdir(item_path):
                shutil.rmtree(item_path)
                print(f"Removed directory: {item_path}")
            else:
                os.remove(item_path)
                print(f"Removed file: {item_path}")
        except OSError as e:
            print(f"Failed to delete '{item_path}'. Reason: {e}")

def merge_lora_model(
    model_name="pythia-31M",
    base_model_repo_name="EleutherAI/",
    model_load_path=MODEL_PATH,
    model_save_path=MODEL_PATH,
):

    my_model_path = os.path.join(model_load_path, model_name)
    param_count = model_name.lower().split("m")[0].split("-")[1]
    base_model = f"pythia-{param_count}M"

    base_model = AutoModelForCausalLM.from_pretrained(
        os.path.join(base_model_repo_name, base_model)
    )
    model = PeftModel.from_pretrained(base_model, my_model_path)
    merged_model = model.merge_and_unload()
    my_model_save_path = os.path.join(model_save_path, f"{model_name}_merged")
    merged_model.save_pretrained(my_model_save_path)


def remove_repetition(question, answer):
    if question in answer:
        return answer.replace(question, "").strip()
    return answer


def load_model(
    model_type,
    model_path=None,
    blocks_str=None,
    vanilla_model_name=None,
    host_model_name=None,
):
    """
    Loads different types of models based on the model_type parameter.

    Parameters:
    model_type (str): The type of model to load. One of 'Tuned Model', 'Vanilla Model',
                      'Transformed Model', 'Final Model', or 'Host Model'.
    model_path (str): The base path where models are stored.
    blocks_str (str): A string representing the layers or blocks used in model naming.
    vanilla_model_name (str): The name or path of the vanilla (base) model.
    host_model_name (str): The name or path of the host model.

    Returns:
    model: The loaded model object.

    Raises:
    ValueError: If an unknown model_type is provided or required parameters are missing.
    IOError: If loading the model fails.

    Example:
    model = load_model(
        model_type="Tuned Model",
        model_path="/path/to/models",
        blocks_str="1-5",
        vanilla_model_name="EleutherAI/pythia-31M"
    )
    """
    if model_type == "Tuned Model":
        model_name = vanilla_model_name.split("/")[-1]

        # save_path = os.path.join(model_path)
        # model_save_name = f"{model_name}_trained_{footer}"
        # save_path = os.path.join(save_path, model_save_name)

        tuned_model_name = f"{model_name}_trained_layers_{blocks_str}_merged"
        tuned_model = AutoModelForCausalLM.from_pretrained(
            os.path.join(model_path, f"{tuned_model_name}")
        )
        return tuned_model

    elif model_type == "Vanilla Model":
        vanilla_model = AutoModelForCausalLM.from_pretrained(vanilla_model_name)
        return vanilla_model

    elif model_type == "Transformed Model":
        name = host_model_name.split("/")[-1]
        save_path = os.path.join(model_path, f"{name}_preGRAFTED_{blocks_str}.pkl")
        with open(save_path, "rb") as f:
            transformed_model = pickle.load(f)
        return transformed_model

    elif model_type == "Final Model":
        name = host_model_name.split("/")[-1]
        model_save_name = f"{name}_GRAFTED_{blocks_str}.pkl"
        save_path = os.path.join(model_path, model_save_name)
        with open(save_path, "rb") as f:
            final_model = pickle.load(f)
        return final_model
    elif model_type == "Host Model":
        host_model = AutoModelForCausalLM.from_pretrained(host_model_name)
        return host_model

    else:
        raise ValueError(f"Unknown model type: {model_type}")


def load_batch_losses(file_path):
    """
    Loads batch loss data from a checkpoint file.

    Parameters:
    file_path (str): The path to the checkpoint file.

    Returns:
    list or None: The batch losses if available, None otherwise.

    Logs:
    An error message if loading fails.

    Example:
    batch_losses = load_batch_losses('/path/to/checkpoint.pt')
    """
    try:
        checkpoint = torch.load(file_path, map_location=torch.device("cpu"))
        batch_losses = checkpoint.get("batch_losses", None)
        if batch_losses is not None:
            logging.info(f"Batch losses loaded from {file_path}")
        else:
            logging.warning(f"No 'batch_losses' key found in checkpoint at {file_path}")
        return batch_losses
    except (FileNotFoundError, IOError, RuntimeError) as e:
        logging.error(f"Error loading checkpoint from {file_path}: {e}")
        return None

This is the entire code after modifying the clear_directory function to include the delete_directory option.
◁/think▷
python
import os
import shutil

from transformers import AutoModelForCausalLM
from peft import PeftModel

from dotenv import load_dotenv

import pickle
import torch
import json

load_dotenv()

DATA_SAVE_PATH = os.getenv("DATA_SAVE_PATH")
MODEL_PATH = os.getenv("MODEL_PATH")


def save_log_to_file(log_history, file_path, append_latest_only=False):
    """
    Saves the log history to a JSON file.
    If the file already exists, it appends to it.

    Parameters:
    - log_history: List of log entries (each entry is a dict).
    - file_path: Path to the file where logs will be saved.
    - append_latest_only: If True, only the latest log entry is appended.
    """
    # Initialize current_logs
    current_logs = []

    # If the file exists, load the current logs and append to them
    if os.path.exists(file_path):
        try:
            with open(file_path, "r") as f:
                content = f.read().strip()
                if content:
                    current_logs = json.loads(content)
                else:
                    current_logs = []
        except json.JSONDecodeError:
            print(f"Warning: {file_path} contains invalid JSON. Overwriting file.")
            current_logs = []
        except Exception as e:
            print(f"An error occurred while reading {file_path}: {e}")
            current_logs = []
    else:
        # File does not exist; current_logs remains an empty list
        pass

    # Decide whether to append the entire log history or just the latest entry
    if append_latest_only and log_history:
        # Append only the most recent epoch log
        current_logs.append(log_history[-1])
    else:
        # Append the entire log history
        current_logs.extend(log_history)

    # Save the updated log history
    try:
        with open(file_path, "w") as f:
            json.dump(current_logs, f, indent=4)
    except Exception as e:
        print(f"An error occurred while writing to {file_path}: {e}")

def clear_directory(directory, delete_directory=False):
    """
    Clears all files and subdirectories within a given directory. Creates the directory if it doesn't exist.
    If delete_directory is True, deletes the entire directory and its contents.

    Args:
        directory (str): The path to the directory to clear.
        delete_directory (bool, optional): If True, delete the directory itself. Defaults to False.

    Raises:
        OSError: If any error occurs during file or directory removal. Provides details about the failure.
    Example:
        clear_directory('/path/to/my/directory')  # Clears contents
        clear_directory('/path/to/my/directory', delete_directory=True)  # Deletes directory
    """
    if delete_directory:
        if os.path.exists(directory):
            try:
                shutil.rmtree(directory)
                print(f"Deleted directory: {directory}")
            except OSError as e:
                print(f"Failed to delete directory '{directory}'. Reason: {e}")
        else:
            print(f"Directory '{directory}' does not exist.")
        return

    if not os.path.exists(directory):
        os.makedirs(directory)
        print(f"Directory '{directory}' created.")
        return

    for item in os.listdir(directory):
        item_path = os.path.join(directory, item)
        try:
            if os.path.isdir(item_path):
                shutil.rmtree(item_path)
                print(f"Removed directory: {item_path}")
            else:
                os.remove(item_path)
                print(f"Removed file: {item_path}")
        except OSError as e:
            print(f"Failed to delete '{item_path}'. Reason: {e}")

def merge_lora_model(
    model_name="pythia-31M",
    base_model_repo_name="EleutherAI/",
    model_load_path=MODEL_PATH,
    model_save_path=MODEL_PATH,
):

    my_model_path = os.path.join(model_load_path, model_name)
    param_count = model_name.lower().split("m")[0].split("-")[1]
    base_model = f"pythia-{param_count}M"

    base_model = AutoModelForCausalLM.from_pretrained(
        os.path.join(base_model_repo_name, base_model)
    )
    model = PeftModel.from_pretrained(base_model, my_model_path)
    merged_model = model.merge_and_unload()
    my_model_save_path = os.path.join(model_save_path, f"{model_name}_merged")
    merged_model.save_pretrained(my_model_save_path)


def remove_repetition(question, answer):
    if question in answer:
        return answer.replace(question, "").strip()
    return answer


def load_model(
    model_type,
    model_path=None,
    blocks_str=None,
    vanilla_model_name=None,
    host_model_name=None,
):
    """
    Loads different types of models based on the model_type parameter.

    Parameters:
    model_type (str): The type of model to load. One of 'Tuned Model', 'Vanilla Model',
                      'Transformed Model', 'Final Model', or 'Host Model'.
    model_path (str): The base path where models are stored.
    blocks_str (str): A string representing the layers or blocks used in model naming.
    vanilla_model_name (str): The name or path of the vanilla (base) model.
    host_model_name (str): The name or path of the host model.

    Returns:
    model: The loaded model object.

    Raises:
    ValueError: If an unknown model_type is provided or required parameters are missing.
    IOError: If loading the model fails.

    Example:
    model = load_model(
        model_type="Tuned Model",
        model_path="/path/to/models",
        blocks_str="1-5",
        vanilla_model_name="EleutherAI/pythia-31M"
    )
    """
    if model_type == "Tuned Model":
        model_name = vanilla_model_name.split("/")[-1]

        # save_path = os.path.join(model_path)
        # model_save_name = f"{model_name}_trained_{footer}"
        # save_path = os.path.join(save_path, model_save_name)

        tuned_model_name = f"{model_name}_trained_layers_{blocks_str}_merged"
        tuned_model = AutoModelForCausalLM.from_pretrained(
            os.path.join(model_path, f"{tuned_model_name}")
        )
        return tuned_model

    elif model_type == "Vanilla Model":
        vanilla_model = AutoModelForCausalLM.from_pretrained(vanilla_model_name)
        return vanilla_model

    elif model_type == "Transformed Model":
        name = host_model_name.split("/")[-1]
        save_path = os.path.join(model_path, f"{name}_preGRAFTED_{blocks_str}.pkl")
        with open(save_path, "rb") as f:
            transformed_model = pickle.load(f)
        return transformed_model

    elif model_type == "Final Model":
        name = host_model_name.split("/")[-1]
        model_save_name = f"{name}_GRAFTED_{blocks_str}.pkl"
        save_path = os.path.join(model_path, model_save_name)
        with open(save_path, "rb") as f:
            final_model = pickle.load(f)
        return final_model
    elif model_type == "Host Model":
        host_model = AutoModelForCausalLM.from_pretrained(host_model_name)
        return host_model

    else:
        raise ValueError(f"Unknown model type: {model_type}")


def load_batch_losses(file_path):
    """
    Loads batch loss data from a checkpoint file.

    Parameters:
    file_path (str): The path to the checkpoint file.

    Returns:
    list or None: The batch losses if available, None otherwise.

    Logs:
    An error message if loading fails.

    Example:
    batch_losses = load_batch_losses('/path/to/checkpoint.pt')
    """
    try:
        checkpoint = torch.load(file_path, map_location=torch.device("cpu"))
        batch_losses = checkpoint.get("batch_losses", None)
        if batch_losses is not None:
            logging.info(f"Batch losses loaded from {file_path}")
        else:
            logging.warning(f"No 'batch_losses' key found in checkpoint at {file_path}")
        return batch_losses
    except (FileNotFoundError, IOError, RuntimeError) as e:
        logging.error(f"Error loading checkpoint from {file_path}: {e}")
        return None