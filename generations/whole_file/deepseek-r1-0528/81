To solve this problem, we need to replace the `MockChild` component with the `Sprite` component and ensure it fills its container while maintaining proper overflow handling. The CSS styles provided already include `overflow: hidden` for the `.characterCell` container, so we just need to ensure the `Sprite` component fills this container.

### Approach
1. **Replace `MockChild` with `Sprite`**: The `MockChild` component in the first `.characterCell` should be replaced with the `Sprite` component using `spriteName="PortraitAlfonse"`.
2. **Adjust Styles**: To make the `Sprite` fill its container, we apply inline styles `width: '100%'` and `height: '100%'`. This ensures the sprite expands to fill the available space in the cell.
3. **Maintain Existing Structure**: The rest of the component remains unchanged to preserve functionality.

### Solution Codejavascript/react
import React from 'react';
import styles from './CharacterStatUI.module.css';
import Sprite from '../sprite/Sprite';
import SingleCharacterStatUI from '../single-character-stat-ui/SingleCharacterStatUI';
import MockChild from '../mock-child/MockChild';

const CharacterStatUI = ({ charName, level, wpn, hp, atk, spd, def, res }) => {
    const characterStats = [
        { characterStatType: 'NAME', characterStatValue: charName },
        { characterStatType: 'LV', characterStatValue: level },
        { characterStatType: 'WPN', characterStatValue: wpn },
        { characterStatType: 'HP', characterStatValue: hp },
        { characterStatType: 'ATK', characterStatValue: atk },
        { characterStatType: 'SPD', characterStatValue: spd },
        { characterStatType: 'DEF', characterStatValue: def },
        { characterStatType: 'RES', characterStatValue: res },
    ];

    console.log('Character Stats:', {
        charName,
        level,
        wpn,
        hp,
        atk,
        spd,
        def,
        res
    });

    const characterStatsSlice1 = characterStats.slice(0, 4);
    const characterStatsSlice2 = characterStats.slice(4);

    return (
        <div className={styles.characterTable}>
            <div className={styles.characterCell}>
                <Sprite spriteName="PortraitAlfonse" style={{ width: '100%', height: '100%' }} />
            </div>
                <div className={styles.characterCell}>
                    {characterStatsSlice1.map((item, index) => (
                        <SingleCharacterStatUI
                            key={index}
                            characterStatType={item.characterStatType}
                            characterStatValue={item.characterStatValue}
                            backgroundColor="white"
                        />
                    ))}
                </div>
                <div className={styles.characterCell}>
                    {characterStatsSlice2.map((item, index) => (
                        <SingleCharacterStatUI
                            key={index}
                            characterStatType={item.characterStatType}
                            characterStatValue={item.characterStatValue}
                            backgroundColor="white"
                        />                        
                    ))}
                </div>
            </div>
    );
};

export default CharacterStatUI;

### Explanation
- **Replacement of `MockChild`**: The `MockChild` component is replaced with the `Sprite` component, which uses the `PortraitAlfonse` sprite.
- **Inline Styles**: The `style` prop is added to the `Sprite` component to set `width` and `height` to `100%`, ensuring it fills its parent container.
- **Overflow Handling**: The `.characterCell` class already has `overflow: hidden`, which clips any overflow from the sprite, maintaining the UI's clean appearance.
- **Unchanged Logic**: The rest of the component, including the stat slicing and rendering logic, remains unchanged to preserve existing functionality.

This solution efficiently integrates the sprite into the UI while ensuring it properly fits within its designated container.