import numpy as np

def conjugate_gradient(A, b, x0, tol=1e-5, max_iter=None):
    """
    Решает систему линейных уравнений Ax = b методом сопряжённых градиентов.
    
    Параметры:
    A : массив, функция или матрица в формате 2D numpy array
        Матрица системы или функция, обрабатывающая умножение A*x
    b : 1D numpy array
        Вектор правой части системы
    x0 : 1D numpy array
        Начальное приближение решения
    tol : float, опционально
        Допуск сходимости (остановки). Стандартное значение 1e-5
    max_iter : int, опционально
        Максимальное количество итераций. Стандартное значение len(b)
        
    Возвращает:
    x : 1D numpy array
        Приближенное решение системы Ax = b
    """
    # Преобразование A в функцию (если передана матрица)
    if callable(A):
        A_func = A
    else:
        # Для матрицы создаем функцию умножения A на вектор
        A_func = lambda x: A @ x

    x = x0.copy()
    b = np.asarray(b).flatten()
    
    # Начальные векторы
    r = b - A_func(x)
    p = r.copy()
    
    # Начальная квадратичная норма невязки
    rsold = r.dot(r)
    
    # Вычисляем максимальное число итераций, если не задано
    if max_iter is None:
        max_iter = len(b)
    
    # Обработка случая нулевой начальной невязки
    if np.sqrt(rsold) < tol:
        return x
    
    for i in range(max_iter):
        # Вычисляем движение по направлению
        Ap = A_func(p)
        
        # Вычисляем скалярное произведение (p, Ap)
        pAp = p.dot(Ap)
        
        # Проверка положительной определенности (p, Ap)
        if pAp <= 0:
            # Если не положительно, прервать выполнение
            break
            
        # Шаг размера alpha
        alpha = rsold / pAp
        
        # Обновление решения и невязки
        x += alpha * p
        r -= alpha * Ap
        
        # Новая квадратичная норма невязки
        rsnew = r.dot(r)
        
        # Проверка критерия остановки
        if np.sqrt(rsnew) < tol:
            break
        
        # Параметр пересчета направления спуска
        beta = rsnew / rsold
        
        # Обновление направления спуска
        p = r + beta * p
        
        # Обновление значения старой невязки
        rsold = rsnew
        
    return x