
The new implementation allows separate clustering for specified feature sets. The `cluster_data` function now takes a dictionary mapping new cluster column names to tuples of feature columns. Clustering is performed independently for each feature set using KMeans. Visualization is now done per cluster set using the first two features from its feature set.

Changes made:
1. `cluster_data` now accepts `clustering_config` dict instead of `cluster_feature_name`
2. Added feature set looping for independent clustering
3. Added per-cluster-set visualization using feature set columns
4. Preserved silhouette score calculation for each cluster set
5. Added explicit numpy import for functionality
python
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score
import numpy as np

def cluster_data(features_transformed, clustering_config, n_clusters=2, clustering_method='kmeans'):
    """
    Выполняет независимую кластеризацию данных для указанных наборов признаков.

    Args:
        features_transformed (pandas.DataFrame): Преобразованный DataFrame с параметрами.
        clustering_config (dict): Словарь вида {имя_кластера: (признак1, признак2), ...}
        n_clusters (int): Количество кластеров для всех кластеризаций.
        clustering_method (str): Метод кластеризации ('kmeans').

    Returns:
        pandas.DataFrame: DataFrame с добавленными столбцами меток кластеров.
    """
    if features_transformed is None:
        print("Сначала выполните преобразование данных (этап 5).")
        return None

    features_for_clustering = features_transformed.copy()

    if clustering_method != 'kmeans':
        print("Неподдерживаемый метод кластеризации.")
        return None

    for cluster_col_name, feature_columns in clustering_config.items():
        # Выбор только указанных признаков для текущей кластеризации
        features_subset = features_for_clustering[list(feature_columns)]
        
        model = KMeans(n_clusters=n_clusters, random_state=42, n_init=10)
        cluster_labels = model.fit_predict(features_subset)
        
        features_transformed[cluster_col_name] = cluster_labels
        
        # Оценка качества кластеризации (коэффициент силуэта)
        if len(np.unique(cluster_labels)) > 1:
            silhouette_avg = silhouette_score(features_subset, cluster_labels)
            print(f"Коэффициент силуэта для '{cluster_col_name}' ({n_clusters} кластеров): {silhouette_avg:.4f}")
        else:
            print(f"Невозможно рассчитать силуэт для '{cluster_col_name}' ({n_clusters} кластеров)")

    print("Все кластеризации выполнены. Метки кластеров добавлены в DataFrame.")
    return features_transformed

# Выполнение кластеризации (после этапа 5 и до этапа 6)
if 'features_transformed' in locals() and features_transformed is not None:
    # Настройки кластеризации
    clustering_config = {
        'cluster_set1': ('feature1', 'feature2'),  # Пример для первого набора признаков
        'cluster_set2': ('feature3',)              # Пример для второго набора (одного признака)
    }
    n_clusters = 3  # Количество кластеров для всех кластеризаций
    
    features_transformed = cluster_data(features_transformed, clustering_config, n_clusters)
    
    # Визуализация результатов для каждого набора признаков
    for cluster_col_name, feature_columns in clustering_config.items():
        if len(feature_columns) >= 2:
            plt.figure(figsize=(8, 6))
            plt.scatter(features_transformed[feature_columns[0]], 
                        features_transformed[feature_columns[1]], 
                        c=features_transformed[cluster_col_name], 
                        cmap='viridis')
            plt.xlabel(feature_columns[0])
            plt.ylabel(feature_columns[1])
            plt.title(f'Результаты кластеризации "{cluster_col_name}"')
            plt.colorbar(label='Номер кластера')
            plt.show()
        else:
            print(f"Набор '{cluster_col_name}' содержит только {len(feature_columns)} признак(а) - " 
                  f"визуализация на плоскости невозможна")
else:
    print("Сначала выполните этап 5 (Преобразование данных).")