import numpy as np
from typing import Dict, Any

from simulator.model.bidder import _Bidder
from simulator.model.traffic import Traffic
from simulator.simulation.modules import History


class Mystique(_Bidder):
    """
    Mystique bidding agent implementation based on a PID-like controller
    to manage campaign budget pacing.
    """
    default_params = {
        'traffic_path': '../data/traffic_share.csv',
        'pf0': 300,
        'C_max': 50,
        'C_min': 5,
        'E_max': 10,
        'E_gmc': 10
    }

    def __init__(self, params: dict = None):
        """
        Initializes the Mystique bidder.

        Args:
            params (dict, optional): Bidder parameters. Defaults to None.
        """
        super().__init__()

        self.day_initial_balance = 0
        self.count = 0

        params = params or {}

        traffic_path = params.get(
            "traffic_path", self.default_params['traffic_path']
        )
        self.traffic = Traffic(path=traffic_path)

        self.C_max = params.get('C_max', self.default_params['C_max'])
        self.C_min = params.get('C_min', self.default_params['C_min'])
        self.E_max = params.get('E_max', self.default_params['E_max'])
        self.E_gmc = params.get('E_gmc', self.default_params['E_gmc'])

        self.balance_previous = np.array([])
        self.bid_previous = np.array([])
        self.timestamp_previous = np.array([])

    def place_bid(
        self, bidding_input_params: Dict[str, Any], history: History
    ) -> float:
        """
        Calculates and places a bid for an ad impression.

        Args:
            bidding_input_params: Parameters for the current bid.
            history: Not used in this implementation, but required by
                     the interface.

        Returns:
            The calculated bid value.
        """
        self.count += 1
        start = bidding_input_params['campaign_start_time']
        end = bidding_input_params['campaign_end_time']
        initial_balance = bidding_input_params['initial_balance']
        balance = bidding_input_params['balance']
        curr_time = bidding_input_params['curr_time']

        if len(self.bid_previous) == 0:
            # First bid of the campaign, use a default value.
            bid = 300.0
            self._append_history(balance, curr_time, bid)
            return bid

        # --- Time and budget calculations ---
        day = (curr_time - start) // 3600 // 24
        hour = (curr_time - start) // 3600 % 24
        desired_days = (end - start) // 3600 // 24

        # Avoid division by zero for campaigns shorter than a day
        day_quote = initial_balance / desired_days if desired_days > 0 else initial_balance

        # --- Traffic and spend planning ---
        region_id = bidding_input_params['region_id']
        first_day_end = start + 3600 * 24
        traffic_campaign = self.traffic.get_traffic_share(
            region_id, start, first_day_end
        )
        hours = np.arange(start, first_day_end, 3600)

        traffic_list = np.array([
            self.traffic.get_traffic_share(region_id, h, h + 3600) for h in hours
        ])

        if traffic_campaign != 0:
            traffic_list = traffic_list / traffic_campaign
        else:
            traffic_list = np.zeros_like(traffic_list)
        target_spend = day_quote * np.cumsum(traffic_list)

        # --- Find initial balance for the current day ---
        hour_previous = [(t - start) // 3600 % 24 for t in self.timestamp_previous]

        # Default to previous balance, then refine
        initial_day_balance = self.balance_previous[-1]
        if day == 0:
            initial_day_balance = initial_balance
        else:
            # Check if the hour has rolled over since the last bid
            if hour_previous[-1] > hour:
                initial_day_balance = self.balance_previous[-1]
            else:
                # Find balance at day start by finding where hour number decreased
                # Look back up to 12 steps.
                for i in range(len(hour_previous) - 1,
                               max(-1, len(hour_previous) - 12), -1):
                    if hour_previous[i] < hour_previous[i - 1]:
                        initial_day_balance = self.balance_previous[i]
                        break

        # --- Bid calculation logic ---
        # If we have already spent today's quote, bid low to stop spending.
        if initial_day_balance - balance >= day_quote:
            if self.count % 3 != 1:
                bid = self.bid_previous[-1]
            else:
                bid = 0.95 * self.bid_previous[-1]
            self._append_history(balance, curr_time, bid)
            return bid

        # --- PID-like control to adjust bid based on spending pace ---
        # 1. Calculate proportional error (how far off are we from target spend)
        spend_error = (initial_day_balance - balance - target_spend[int(hour)])

        # 2. Calculate derivative error (is our spending rate too fast/slow)
        gradient_spend_error = 0
        if int(hour) > 0:
            desired_gradient = (target_spend[int(hour)] -
                                target_spend[int(hour) - 1]) / 3600
            time_delta = curr_time - self.timestamp_previous[-1]
            if time_delta > 0:
                real_gradient = (self.balance_previous[-1] - balance) / time_delta
                gradient_spend_error = real_gradient - desired_gradient

        # 3. Calculate weights for proportional and derivative terms
        if gradient_spend_error == 0:
            tau = 1_000_000  # A large number to make ws dominant
        else:
            tau = -spend_error / gradient_spend_error

        if tau < 0:
            ws = 0.5
            wg = 0.5
        else:
            ws = min(0.9, 0.2 * tau)
            wg = 1 - ws

        # 4. Calculate final bid adjustment
        spend_error_c = min(
            self.C_max, self.C_max * abs(spend_error) / self.E_max
        )
        gradient_spend_error_i = min(1, abs(gradient_spend_error))
        gradient_spend_error_c = max(
            self.C_min,
            self.C_max * gradient_spend_error_i / self.E_gmc
        )

        # Adjust bid only every 3 steps to reduce oscillations
        if self.count % 3 == 1:
            bid = (self.bid_previous[-1]
                   - ws * spend_error_c * np.sign(spend_error)
                   - wg * gradient_spend_error_c * np.sign(gradient_spend_error))
        else:
            bid = self.bid_previous[-1]

        self._append_history(balance, curr_time, bid)
        return bid

    def _append_history(self, balance: float, curr_time: int, bid: float):
        """Appends the current state to the internal history arrays."""
        self.balance_previous = np.pad(
            self.balance_previous,
            pad_width=(0, 1),
            constant_values=balance,
        )
        self.timestamp_previous = np.pad(
            self.timestamp_previous,
            pad_width=(0, 1),
            constant_values=curr_time,
        )
        self.bid_previous = np.pad(
            self.bid_previous,
            pad_width=(0, 1),
            constant_values=bid,
        )