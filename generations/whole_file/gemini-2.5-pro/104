An analysis of the original code reveals several major syntax and structural errors. The `unittest.TestCase` class definition, its `__main__` block, and an `import` statement were incorrectly placed inside the `add_edge` method. Additionally, the methods `remove_vertex`, `remove_edge`, `dfs`, and `bfs` were improperly nested within the `__str__` method. The `if __name__ == "__main__"` block at the end also contained print statements with unescaped newlines which could be considered a minor bug.

The corrected implementation untangles these components into a single, valid Python script. It moves all imports to the top of the file for clarity. The `Graph` class methods are restructured to the correct indentation level, and the broken `add_edge` method is repaired. The `TestGraph` class, which defines the unit tests, is placed after the `Graph` class. A logical error in the `test_dfs` method's assertion, which would have always failed, has also been fixed. Finally, the main demonstration block is cleaned up and placed at the end, making the entire file executable.
python
import unittest
import io
from contextlib import redirect_stdout

class Graph:
    def __init__(self):
        self.adjacency_list = {}

    def add_vertex(self, vertex):
        if vertex not in self.adjacency_list:
            self.adjacency_list[vertex] = []

    def add_edge(self, vertex1, vertex2):
        if vertex1 in self.adjacency_list and vertex2 in self.adjacency_list:
            self.adjacency_list[vertex1].append(vertex2)
            self.adjacency_list[vertex2].append(vertex1)

    def __str__(self):
        return str(self.adjacency_list)

    def remove_vertex(self, vertex):
        if vertex in self.adjacency_list:
            for neighbor in self.adjacency_list[vertex]:
                self.adjacency_list[neighbor].remove(vertex)
            del self.adjacency_list[vertex]

    def remove_edge(self, vertex1, vertex2):
        if vertex1 in self.adjacency_list and vertex2 in self.adjacency_list:
            if vertex2 in self.adjacency_list[vertex1]:
                self.adjacency_list[vertex1].remove(vertex2)
            if vertex1 in self.adjacency_list[vertex2]:
                self.adjacency_list[vertex2].remove(vertex1)

    def dfs(self, start_vertex, visited=None):
        """
        Perform a depth-first search (DFS) starting from the given vertex.
        Args:
            start_vertex: The starting vertex for the DFS.
            visited (set, optional): A set of already visited vertices. Defaults to None.
        Returns:
            None
        """
        if visited is None:
            visited = set()
        
        visited.add(start_vertex)
        print(start_vertex, end=' ')
        
        if start_vertex in self.adjacency_list:
            for neighbor in self.adjacency_list[start_vertex]:
                if neighbor not in visited:
                    self.dfs(neighbor, visited)
    
    def bfs(self, start_vertex):
        visited = set()
        queue = [start_vertex]
        visited.add(start_vertex)
        
        while queue:
            vertex = queue.pop(0)
            print(vertex, end=' ')
            
            if vertex in self.adjacency_list:
                for neighbor in self.adjacency_list[vertex]:
                    if neighbor not in visited:
                        visited.add(neighbor)
                        queue.append(neighbor)

class TestGraph(unittest.TestCase):

    def setUp(self):
        self.graph = Graph()

    def test_add_vertex(self):
        self.graph.add_vertex('A')
        self.assertEqual(self.graph.adjacency_list, {'A': []})
        self.graph.add_vertex('B')
        self.assertEqual(self.graph.adjacency_list, {'A': [], 'B': []})
        # Adding a duplicate vertex should not modify the graph
        self.graph.add_vertex('A')  
        self.assertEqual(self.graph.adjacency_list, {'A': [], 'B': []})

    def test_add_edge(self):
        self.graph.add_vertex('A')
        self.graph.add_vertex('B')
        self.graph.add_edge('A', 'B')
        self.assertEqual(self.graph.adjacency_list, {'A': ['B'], 'B': ['A']})
        # Adding an edge with non-existent vertices should not modify the graph
        self.graph.add_edge('A', 'C')  
        self.assertEqual(self.graph.adjacency_list, {'A': ['B'], 'B': ['A']})
        self.graph.add_edge('D','E')
        self.assertEqual(self.graph.adjacency_list, {'A': ['B'], 'B': ['A']})

    def test_remove_vertex(self):
        self.graph.add_vertex('A')
        self.graph.add_vertex('B')
        self.graph.add_edge('A','B')
        self.graph.remove_vertex('A')
        self.assertEqual(self.graph.adjacency_list, {'B': []})
        #removing a non-existent vertex shouldn't modify the graph
        self.graph.remove_vertex('C')
        self.assertEqual(self.graph.adjacency_list, {'B': []})

    def test_remove_edge(self):
        self.graph.add_vertex('A')
        self.graph.add_vertex('B')
        self.graph.add_edge('A','B')
        self.graph.remove_edge('A','B')
        self.assertEqual(self.graph.adjacency_list, {'A': [], 'B': []})
        # Removing a non-existent edge should not do anything
        self.graph.remove_edge('A','C')
        self.assertEqual(self.graph.adjacency_list, {'A': [], 'B': []})

    def test_dfs(self):
        self.graph.add_vertex('A')
        self.graph.add_vertex('B')
        self.graph.add_vertex('C')
        self.graph.add_edge('A', 'B')
        self.graph.add_edge('A', 'C')
        self.graph.add_edge('B','C')

        # Redirect stdout to capture the print output
        f = io.StringIO()
        with redirect_stdout(f):
            self.graph.dfs('A')
        output = f.getvalue().strip()
        # DFS order can vary, so we check if the output is one of the valid ones.
        possible_outputs = {"A B C", "A C B"}
        self.assertIn(output, possible_outputs)

    def test_bfs(self):
         self.graph.add_vertex('A')
         self.graph.add_vertex('B')
         self.graph.add_vertex('C')
         self.graph.add_edge('A', 'B')
         self.graph.add_edge('A', 'C')
         self.graph.add_edge('B','C')

         f = io.StringIO()
         with redirect_stdout(f):
             self.graph.bfs('A')
         output = f.getvalue().strip()
         # BFS order is deterministic based on insertion order of neighbors
         self.assertEqual(output,"A B C")

if __name__ == "__main__":
    # To run the integrated unit tests, execute from your terminal:
    # python -m unittest your_script_name.py

    # Create a new graph instance
    graph = Graph()

    # Add vertices
    graph.add_vertex('A')
    graph.add_vertex('B')
    graph.add_vertex('C')
    graph.add_vertex('D')

    # Add edges
    graph.add_edge('A', 'B')
    graph.add_edge('A', 'C')
    graph.add_edge('B', 'D')

    # Display the graph
    print("Graph adjacency list:")
    print(graph)

    # Perform DFS starting from vertex 'A'
    print("\nDFS starting from vertex 'A':")
    graph.dfs('A')

    # Perform BFS starting from vertex 'A'
    print("\n\nBFS starting from vertex 'A':")
    graph.bfs('A')
