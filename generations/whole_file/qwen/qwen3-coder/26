import numpy as np

def conjugate_gradient(A, b, x0=None, tol=1e-6, max_iter=None):
    """
    Реализация метода сопряжённых градиентов для решения СЛАУ Ax = b
    
    Параметры:
    A : array-like, shape (n, n)
        Симметричная положительно определённая матрица
    b : array-like, shape (n,)
        Вектор правой части
    x0 : array-like, shape (n,), optional
        Начальное приближение (по умолчанию - нулевой вектор)
    tol : float, optional
        Точность решения (по умолчанию 1e-6)
    max_iter : int, optional
        Максимальное число итераций (по умолчанию n)
    
    Возвращает:
    x : ndarray, shape (n,)
        Приближенное решение системы
    """
    A = np.asarray(A)
    b = np.asarray(b)
    n = len(b)
    
    if max_iter is None:
        max_iter = n
    
    if x0 is None:
        x = np.zeros(n)
    else:
        x = np.asarray(x0)
    
    r = b - A @ x  # начальный вектор невязки
    p = r.copy()   # начальный вектор поиска
    rsold = r @ r  # квадрат нормы невязки
    
    for i in range(max_iter):
        Ap = A @ p
        alpha = rsold / (p @ Ap)  # шаг спуска
        x = x + alpha * p
        r = r - alpha * Ap
        rsnew = r @ r
        
        if np.sqrt(rsnew) < tol:
            break
            
        beta = rsnew / rsold   # коэффициент коррекции направления
        p = r + beta * p       # новое направление поиска
        rsold = rsnew
    
    return x