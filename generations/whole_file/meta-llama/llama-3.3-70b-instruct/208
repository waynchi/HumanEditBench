function createTurnState(allyStates, foeStates) {
  let currentTurn = "player";

  // 根据哪个组仍然有可以行动的单位来确定当前回合
  function determineCurrentTurn() {
    const hasActedAlly = allyStates.every(unit => unit.hasActed);
    const hasActedFoe = foeStates.every(unit => unit.hasActed);

    if (hasActedAlly && hasActedFoe) {
      // 如果两个都已经行动完成，则说明回合结束，切换到另一方回合
      currentTurn = currentTurn === "player" ? "cpu" : "player";
    } else if (hasActedAlly) {
      // 如果盟友已经行动完成，则CPU开始行动
      currentTurn = "cpu";
    } else if (hasActedFoe) {
      // 如果敌方已经行动完成，则盟友开始行动
      currentTurn = "player";
    }
  }

  let turnNumber = 1;

  function getCurrentTurn() {
    determineCurrentTurn();
    return currentTurn;
  }

  function getTurnNumber() {
    return turnNumber;
  }

  function nextTurn() {
    if (currentTurn === "player") {
      currentTurn = "cpu";
      // 在这里实现CPU逻辑（例如，AI移动和动作）
      allyStates.forEach(unit => unit.hasActed = true);
      foeStates.forEach(unit => unit.hasActed = false);
      cpuTurn();
    } else {
      currentTurn = "player";
      foeStates.forEach(unit => unit.hasActed = true);
      allyStates.forEach(unit => unit.hasActed = false);
      turnNumber++; // 仅在玩家回合后增加回合数
    }
     // 在新回合开始时重置所有单位的行动可用性
  }

  function cpuTurn() {
    // 示例 CPU 行为（用您实际的 AI 逻辑替换）
    for (const cpuUnit of foeStates) {
      if (!cpuUnit.hasActed) { // 检查该单位在此回合中是否已行动过
        // 执行CPU动作（例如，移动，攻击）
        // ...在这里编写你的CPU AI逻辑...

        cpuUnit.hasActed = true; // 将该单位标记为已行动
      }
    }

    // 在所有CPU单元都已行动（或选择不行动）后，结束CPU回合
    nextTurn(); // 自动切换回玩家的回合
  }  

  return {
    getCurrentTurn,
    getTurnNumber,
    nextTurn
  };
}

export { createTurnState };