import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.stats import skew

# Need to speed up and rewrite the medcouple function
def medcouple(data):
    """
    Compute the medcouple robust measure of skewness.
    This implementation uses NumPy broadcasting for efficiency
    and handles the case with repeated median values.
    """
    data = np.sort(data)
    median = np.median(data)

    # Split data into left (<= median) and right (>= median)
    left = data[data <= median]
    right = data[data >= median]

    # Number of elements equal to the median
    k = np.sum(data == median)

    if k > 1:
        # Create index grids
        i = np.arange(len(left))[:, None]   # shape (len(left), 1)
        j = np.arange(len(right))[None, :]  # shape (1, len(right))

        # Create value grids
        xi = left[:, None]   # shape (len(left), 1)
        xj = right[None, :]  # shape (1, len(right))

        # Compute numerator and denominator for the kernel h
        numer = (xj - median) - (median - xi)
        denom = xj - xi

        # Allocate result matrix
        h = np.empty_like(denom, dtype=float)

        # Where denominator is not zero, use the usual formula
        mask = denom != 0
        h[mask] = numer[mask] / denom[mask]

        # Where denominator is zero (both xi and xj equal median), use special_h
        special = np.where(
            i + j - 1 < k, -1.0,
            np.where(i + j - 1 == k, 0.0, 1.0)
        )
        h[~mask] = special[~mask]
    else:
        # Simple case without repeated medians
        xi = left[:, None]
        xj = right[None, :]

        numer = (xj - median) - (median - xi)
        denom = xj - xi

        # Avoid division by zero warnings; set those entries to 0
        with np.errstate(divide='ignore', invalid='ignore'):
            h = np.where(denom != 0, numer / denom, 0.0)

    # Return the median of all h-values
    return np.median(h)


def adjusted_boxplot_bounds(data):
    """
    Вычисляет границы adjusted boxplot с учетом skewness-adjusted fences.
    """
    q1 = np.percentile(data, 25)
    q3 = np.percentile(data, 75)
    iqr = q3 - q1
    _medcouple = medcouple(data)

    if _medcouple > 0:
        lower_fence = q1 - 1.5 * np.exp(-4 * _medcouple) * iqr
        upper_fence = q3 + 1.5 * np.exp(3 * _medcouple) * iqr
    else:
        lower_fence = q1 - 1.5 * np.exp(-3 * _medcouple) * iqr
        upper_fence = q3 + 1.5 * np.exp(4 * _medcouple) * iqr

    return lower_fence, upper_fence


def normalize_column(data):
    """
    Нормализация с использованием adjusted boxplot.
    """
    lower_fence, upper_fence = adjusted_boxplot_bounds(data)
    print(lower_fence)
    return (data - lower_fence) / (upper_fence - lower_fence)


# Генерация данных
np.random.seed(42)
data_normal = np.random.normal(loc=50, scale=10, size=10000)
data_skewed = np.random.exponential(scale=20, size=10000)
data_skewed = np.concatenate([data_skewed[5:], [200, 250, 300, -100, -50]])
data_with_outliers = np.concatenate([data_normal, [150, 160, 170]])

# Нормализация
df = pd.DataFrame({
    "Normal": data_normal,
    "Skewed": data_skewed,
    # "With_Outliers": data_with_outliers[3:],
})

normalized_df = df.apply(normalize_column)

plt.figure(figsize=(16, 4), dpi=250)

bins = np.linspace(-5, 200, 206)
bin_width = bins[1] - bins[0]  # Ширина одного бина

for col in df.columns:
    # Вычисляем гистограммы без построения
    hist, _ = np.histogram(df[col], bins=bins)

    # Позиции столбиков для каждой гистограммы
    bin_centers = (bins[:-1] + bins[1:]) / 2

    # Смещение для каждого набора данных
    offset = bin_width / 4
    plt.bar(bin_centers - offset, hist, width=bin_width, align='center', alpha=0.2, label=f'{col}')
    plt.legend()
    plt.title(f"Histogram Before Normalization")
plt.xlim(-10, 200)
plt.show()

bins = np.linspace(-2, 2, 101)
bin_width = bins[1] - bins[0]  # Ширина одного бина

plt.figure(figsize=(16, 4), dpi=250)
for col in normalized_df.columns:
    hist, _ = np.histogram(normalized_df[col], bins=bins)

    # Позиции столбиков для каждой гистограммы
    bin_centers = (bins[:-1] + bins[1:]) / 2
    # Смещение для каждого набора данных
    offset = bin_width / 2
    plt.bar(bin_centers - offset, hist, width=bin_width, align='center', label=f'{col}', alpha=0.2)
    plt.legend()
    plt.title(f"Histogram After Normalization")
plt.show()