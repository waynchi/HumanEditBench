# 导入Pymapdl
# from ansys.mapdl.core import launch_mapdl

# 创建MAPDL实例
# mapdl = launch_mapdl(override=True)

# 定义一个求数组拟合直线的函数def fit_line(x, y):
import numpy as np

def fit_line(x, y):
    """
    求数组拟合直线的函数
    """
    # 计算x和y的平均值
    x_mean = np.mean(x)
    y_mean = np.mean(y)
    
    # 计算x和y的偏差
    x_dev = x - x_mean
    y_dev = y - y_mean
    
    # 计算x和y的偏差的乘积
    xy_dev = x_dev * y_dev
    
    # 计算x的偏差的平方
    x_dev_squared = x_dev ** 2
    
    # 计算直线的斜率和截距
    slope = np.sum(xy_dev) / np.sum(x_dev_squared)
    intercept = y_mean - slope * x_mean
    
    return slope, intercept

# 定义一个求xy    # 定义一个求xy数组二次曲线拟合的函数
def fit_quadratic(x, y):
    """
    求数组二次曲线拟合的函数，并计算拟合值与实际y之间的最大绝对偏差。
    
    参数:
        x, y: 可迭代的数值序列，长度应相等。
        
    返回:
        coeffs: numpy array，二次多项式系数 [a, b, c]，使得 y ≈ a*x^2 + b*x + c
        max_dev: float，拟合值与实际y之间的最大绝对偏差，等于 max(|y - y_fit|)
    """
    # 转为numpy数组并检查长度
    x = np.asarray(x)
    y = np.asarray(y)
    if x.shape != y.shape:
        raise ValueError("x and y must have the same shape")
    
    # 创建一个Vandermonde矩阵
    A = np.vstack([x**2, x, np.ones(len(x))]).T
    
    # 使用最小二乘法求解系数
    coeffs = np.linalg.lstsq(A, y, rcond=None)[0]
    
    # 计算拟合值和残差，进而求最大绝对偏差
    y_fit = A.dot(coeffs)
    residuals = y - y_fit
    max_dev = np.max(np.abs(residuals)) if residuals.size > 0 else 0.0
    
    return coeffs, max_dev