plik = open("dane_obrazki.txt")
maxbitybledne = 0
bityBledne = list()
def czyPoprawny(obrazek): # obrzek zawiera liste łancuchów znaków  i można korzystać z operatora balicowego
                            # obrazek[i][j]
    for wiersz in obrazek[:-1]: # nie liczymy z ostaniego wiersza tam są bity parzystosci
        if wiersz[:-1].count('1') % 2 != int(wiersz[-1]):
            return False
    for i in range(20): # i = 0,1,2,3,4,5,6,7..19
        kolumna = ""
        for j in range(21):  # j = 0,1,2,3,4,5,..20
            kolumna+=obrazek[j][i]
        if kolumna[:-1].count('1')% 2 != int(kolumna[-1]):
            return False
    return True

def czyNaprawialny(obrazek):
    bityKolBleden = 0
    bityWierBledne = 0
    for wiersz in obrazek[:-1]: # nie liczymy z ostaniego wiersza tam są bity parzystosci
        if wiersz[:-1].count('1') % 2 != int(wiersz[-1]):
            bityWierBledne+=1
    for i in range(20): # i = 0,1,2,3,4,5,6,7..19
        kolumna = ""
        for j in range(21):  # j = 0,1,2,3,4,5,..20
            kolumna+=obrazek[j][i]
        if kolumna[:-1].count('1')% 2 != int(kolumna[-1]):
           bityKolBleden+=1
    global maxbitybledne
    if maxbitybledne<(bityKolBleden+bityWierBledne):
        maxbitybledne = bityKolBleden+bityWierBledne
    bityBledne.append(bityKolBleden+bityWierBledne)

    if bityWierBledne >1 :
        return False
    if bityKolBleden > 1:
        return False

    return True

def napraw(obrazek):
    """Wejście stanowi plik tekstowy zawierający dane czarnobiałego obrazka zakodowane jaki piksele.
0 - piksel biały 1 - piksel czarny. 
Każdy wiersz oraz kolumna zwiera na swoim końcu bit parzystości . 
Bit parzystości jest równy 0, jeśli ilość jedynek w wierszy (lub w kolumnie dla kolumn) jest parzysta a 
1 jeśli jest nieparzysta.
np.
0 1 1 0 1 1 bit błędny należy zmienić go na przeciwny
1 1 1 0 1 0
1 1 1 1 1 1
0 1 1 0 0 0
1 1 0 1 1 0
1 1 0 0 0 - bity parzystości kolumny 
 ^
 |- bity parzystości wiersza
Napisz funkcje który znajdzie uszkodzone obrazki oraz je naprawi . tzn Jest to obrazek naprawialny ( 
posiada co najwyżej jeden bit parzystości wiersza i co najwyżej jeden bit parzystości kolumny 
niepoprawny ) a następnie naprawi te obrazy 
Wynik ma zawierać obrazek błędny(naprawialny) oraz obrazek poprawiony"""
    
    wynik = list()

    # Make shallow copies of the original image (list of strings)
    original = obrazek.copy()
    repaired = obrazek.copy()

    # Find bad rows (excluding the last row which holds column parity bits)
    bad_rows = []
    for idx, wiersz in enumerate(obrazek[:-1]):
        if wiersz[:-1].count('1') % 2 != int(wiersz[-1]):
            bad_rows.append(idx)

    # Find bad columns (only first 20 columns are data columns, last row holds column parity bits)
    bad_cols = []
    for i in range(20):
        kolumna = "".join(obrazek[j][i] for j in range(21))
        if kolumna[:-1].count('1') % 2 != int(kolumna[-1]):
            bad_cols.append(i)

    # Based on the type of error, repair accordingly:
    # - if there's one bad row and one bad column -> flip the intersecting data bit
    # - if there's only one bad row -> flip that row's parity bit (last char of the row)
    # - if there's only one bad column -> flip that column's parity bit (in the last row at that column)
    # If there are no bad rows/cols, nothing to change. If more than one of either, the image isn't repairable;
    # however, caller should have checked czyNaprawialny before calling this function.
    if len(bad_rows) > 1 or len(bad_cols) > 1:
        # Not repairable by this function; return original and a copy (unchanged)
        wynik.append(original)
        wynik.append(repaired)
        return wynik

    if bad_rows and bad_cols:
        r = bad_rows[0]
        c = bad_cols[0]
        row_str = repaired[r]
        # Safely flip only if bit is '0' or '1'
        ch = row_str[c]
        if ch == '0':
            newch = '1'
        elif ch == '1':
            newch = '0'
        else:
            # Unexpected character (e.g., space), leave unchanged
            newch = ch
        repaired[r] = row_str[:c] + newch + row_str[c+1:]
    elif bad_rows:
        # Flip the parity bit at the end of that row
        r = bad_rows[0]
        row_str = repaired[r]
        c = len(row_str) - 1
        ch = row_str[c]
        if ch == '0':
            newch = '1'
        elif ch == '1':
            newch = '0'
        else:
            newch = ch
        repaired[r] = row_str[:c] + newch
    elif bad_cols:
        # Flip the parity bit for that column in the last row
        c = bad_cols[0]
        last_row = repaired[-1]
        ch = last_row[c]
        if ch == '0':
            newch = '1'
        elif ch == '1':
            newch = '0'
        else:
            newch = ch
        repaired[-1] = last_row[:c] + newch + last_row[c+1:]
    # else: no changes needed (image already correct)

    wynik.append(original)
    wynik.append(repaired)
    return wynik

poprawne = 0
naprawialne = 0
obrazek = list()
for linia in plik:
    wiersz = linia.strip() # odcinamy białe znaki np enter
   # wiersz = wiersz[:-1]  # tylko dane obrazka bez bitu parzystosci  teraz czytamy cala wiersz danych
    obrazek.append(wiersz)
    if len(obrazek) == 21: # mamy 21 lini czyli cały obrazek razem z wierszam bitów parzystosci
        if czyPoprawny(obrazek):
            poprawne+=1
        elif czyNaprawialny(obrazek):
            naprawialne+=1
            naprawiony = napraw(obrazek)


    if len(obrazek) == 22:  # po 22 lini czyscimy obrazek by czytać wiersze nastepnego obrazka
        obrazek = list()

print(poprawne,naprawialne,200-poprawne-naprawialne)
print(maxbitybledne,max(bityBledne))