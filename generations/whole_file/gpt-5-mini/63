from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

def cluster_data(features_transformed, cluster_specs, n_clusters=2, clustering_method='kmeans'):
    """
    Выполняет кластеризацию данных независимо для указанных наборов столбцов.

    Args:
        features_transformed (pandas.DataFrame): Преобразованный DataFrame с параметрами.
        cluster_specs (dict): Словарь вида {new_col_name: (col1, col2, ...), ...}.
                              Ключи — имена новых столбцов для меток кластеров,
                              значения — кортежи/списки названий столбцов, по которым кластеризуем.
        n_clusters (int or dict): Если int — одно и то же количество кластеров для всех наборов.
                                  Если dict — может задавать количество кластеров для каждого набора,
                                  пример: {'Кластер1': 3, 'Кластер2': 2}
        clustering_method (str): Метод кластеризации ('kmeans' поддерживается).

    Returns:
        pandas.DataFrame: DataFrame с добавленными столбцами меток кластеров.
    """
    if features_transformed is None:
        print("Сначала выполните преобразование данных (этап 5).")
        return None

    if not isinstance(cluster_specs, dict) or len(cluster_specs) == 0:
        print("cluster_specs должен быть непустым словарём вида {new_col: (col1, col2), ...}.")
        return None

    df = features_transformed.copy()

    for new_col, cols in cluster_specs.items():
        # Проверка наличия указанных столбцов
        missing = [c for c in cols if c not in df.columns]
        if missing:
            print(f"Пропуск кластеризации для '{new_col}': отсутствуют столбцы {missing}.")
            df[new_col] = np.nan
            continue

        X = df.loc[:, cols].copy()

        # Попытка приведения к числовому типу (если требуется)
        for c in X.columns:
            if not pd.api.types.is_numeric_dtype(X[c]):
                X[c] = pd.to_numeric(X[c], errors='coerce')

        # Отмечаем строки с пропусками в выбранных признаках — им не будет присвоен кластер
        nan_mask = X.isnull().any(axis=1)
        X_valid = X.loc[~nan_mask]

        if X_valid.shape[0] == 0:
            print(f"Нет валидных строк для кластеризации по '{new_col}' (все значения некорректны).")
            df[new_col] = np.nan
            continue

        # Определяем количество кластеров для данного набора
        if isinstance(n_clusters, dict):
            k = n_clusters.get(new_col, 2)
            if not isinstance(k, int) or k < 1:
                print(f"Неверное значение n_clusters для '{new_col}', используется 2.")
                k = 2
        else:
            k = int(n_clusters)

        if clustering_method == 'kmeans':
            # Проверка: k не больше числа валидных образцов
            if k > X_valid.shape[0]:
                print(f"Невозможно создать {k} кластеров для '{new_col}' — меньше образцов ({X_valid.shape[0]}). Будет использовано k={X_valid.shape[0]}.")
                k = X_valid.shape[0]

            try:
                model = KMeans(n_clusters=k, random_state=42, n_init=10)
                labels_valid = model.fit_predict(X_valid)
            except Exception as e:
                print(f"Ошибка при кластеризации '{new_col}': {e}")
                df[new_col] = np.nan
                continue

            # Оценка качества кластеризации (силуэт)
            if len(np.unique(labels_valid)) > 1 and X_valid.shape[0] > 1:
                try:
                    silhouette_avg = silhouette_score(X_valid, labels_valid)
                    print(f"Коэффициент силуэта для '{new_col}' с {k} кластерами: {silhouette_avg:.4f}")
                except Exception as e:
                    print(f"Не удалось вычислить коэффициент силуэта для '{new_col}': {e}")
            else:
                print(f"Невозможно рассчитать коэффициент силуэта для '{new_col}' ({k} кластер(ов) или все точки в одном кластере).")

            # Создаём колонку и заполняем: для валидных строк — метки, для остальных — np.nan (или -1)
            labels_full = np.full(shape=(df.shape[0],), fill_value=np.nan, dtype=float)
            # Align labels_valid to original index
            labels_full[~nan_mask.values] = labels_valid
            df[new_col] = labels_full.astype(float)
            print(f"Кластеризация выполнена для '{new_col}'. Метки добавлены в столбец '{new_col}'.")
        else:
            print(f"Неподдерживаемый метод кластеризации: {clustering_method}. Пропуск '{new_col}'.")
            df[new_col] = np.nan

    return df

# Выполнение кластеризации (после этапа 5 и до этапа 6)
if 'features_transformed' in locals() and features_transformed is not None:
    # Пример спецификации: ключи — имена новых колонок, значения — кортежи столбцов для кластеризации
    # Подставьте реальные имена столбцов вместо 'столбец1', 'столбец2', 'столбец3'
    cluster_specs = {
        'Кластер1': ('столбец1', 'столбец2'),
        'Кластер2': ('столбец3',)
    }
    # n_clusters может быть либо общим числом, либо словарём по именам кластеров
    n_clusters = 3  # или {'Кластер1': 3, 'Кластер2': 2}

    features_transformed = cluster_data(features_transformed, cluster_specs, n_clusters)

    # Визуализация кластеров (используем первый заданный кластер для отображения)
    first_cluster_name = next(iter(cluster_specs.keys()))
    numerical_features = features_transformed.select_dtypes(include=np.number)
    if numerical_features.shape[1] >= 2:
        plt.figure(figsize=(8, 6))
        # Если в колонке с метками кластера есть NaN — matplotlib обрабатывает их как пропуски
        plt.scatter(numerical_features.iloc[:, 0], numerical_features.iloc[:, 1],
                    c=features_transformed[first_cluster_name], cmap='viridis')
        plt.xlabel(numerical_features.columns[0])
        plt.ylabel(numerical_features.columns[1])
        plt.title(f'Результаты кластеризации ({first_cluster_name})')
        plt.colorbar(label='Номер кластера')
        plt.show()
    else:
        print("Недостаточно числовых признаков для визуализации кластеров на плоскости.")
else:
    print("Сначала выполните этап 5 (Преобразование данных).")