import pandas as pd

class Stock:
	def __init__(self, filename, name):
		self.filename = filename
		try:
			self.data = pd.read_csv(self.filename,index_col=0,parse_dates=True)
		except Exception as e:
			print(f"Unable to read file {self.filename}")
			raise e
		self.data.index.name = 'time'
		self.name = name
		self.attrs = {}

	def get_attr(self, key):
		try:
			return self.attrs[key]
		except KeyError:
			return None

	def set_attr(self, key, value):
		self.attrs[key] = value

	def get(self, i):
		return self.data.iloc[i]

	def get_range(self, s, t):
		return self.data.iloc[s:t+1]

	def __len__(self):
		return len(self.data)

class Transaction:
	def __init__(self, num, price):
		self.num = num
		self.price = price
		self.date = None

	def set_date(self, date):
		self.date = date

class Trade:
	def __init__(self, stock, long=True, num=0, price=0.0):
		self.stock = stock
		self.num = 0
		self.profit = 0
		self.closed = False
		self.long = long

		self.opens = []
		self.closes = []

		if num != 0:
			self.open(num, price)

	def close(self, num, price):
		if num > self.num:
			raise ValueError(f"ERR: Trying to close {num} of {self.stock.name} but only {self.num} available")
		self.num -= num
		self.closes.append(Transaction(num, price))

		if self.long:
			self.profit = self.get_num_closed() * (self.get_avg_close_price() - self.get_avg_open_price())
		else:
			self.profit = self.get_num_closed() * (self.get_avg_open_price() - self.get_avg_close_price())

		if self.num == 0:
			self.closed = True

	def open(self, num, price):
		self.num += num

		self.opens.append(Transaction(num, price))

	def get_equity(self, i):
		current_price = self.stock.get(i)["close"]
		if self.long:
			return self.num * current_price
		else:
			# For short trades, equity could reflect the potential cost to close the position
			return self.num * (self.get_avg_open_price() - current_price)

	def set_date(self, date):
		[transaction.set_date(date) for transaction in self.opens if transaction.date is None]
		[transaction.set_date(date) for transaction in self.closes if transaction.date is None]

	def get_avg_open_price(self):
		total_price = sum(transaction.price * transaction.num for transaction in self.opens)
		total_num = sum(transaction.num for transaction in self.opens)
		return total_price / total_num if total_num else 0
	
	def get_avg_close_price(self):
		total_price = sum(transaction.price * transaction.num for transaction in self.closes)
		total_num = sum(transaction.num for transaction in self.closes)
		return total_price / total_num if total_num else 0

	def get_num_opened(self):
		return sum(transaction.num for transaction in self.opens)

	def get_num_closed(self):
		return sum(transaction.num for transaction in self.closes)

class Strategy:
	def __init__(self):
		self.stocks = []
		self.starting_money = 100000.0
		self.money = self.starting_money
		self.closed_trades = []
		self.open_trades = []
		self.attrs = {}
		self.analyzers = []

	def get_attr(self, key):
		return self.attrs[key]

	def set_attr(self, key, value):
		self.attrs[key] = value

	def add_analyzer(self, analyzer):
		analyzer.strategy = self
		self.analyzers.append(analyzer)

	def has_open_trade(self, stock):
		for trade in self.open_trades:
			if stock is trade.stock:
				return True
		return False

	def get_open_trade(self, stock):
		for trade in self.open_trades:
			if trade.stock is stock:
				return trade
		raise ValueError("No open trade on stock "+str(stock.name))

	def open_trade(self, stock, num, price):
		if self.money < num*price:
			raise ValueError("Insufficient funds: have $"+str(self.money)+" available and trying to open "+str(num)+" of "+str(stock.name)+" at $"+str(price)+" on "+str(stock.get(self.get_attr("i")).name))

		if self.has_open_trade(stock):
			trade = self.get_open_trade(stock)
			trade.open(num, price)
			trade.set_date(stock.get(self.get_attr("i")).name)
		else:
			self.open_trades.append(Trade(stock, True, num, price))
			self.open_trades[-1].set_date(stock.get(self.get_attr("i")).name)

		self.money -= num*price

	def sell(self, stock, num, price):
		if self.has_open_trade(stock):
			trade = self.get_open_trade(stock)
			trade.close(num, price)
			if trade.closed:
				self.open_trades.remove(trade)
				self.closed_trades.append(trade)
			trade.set_date(stock.get(self.get_attr("i")).name)
		else:
			raise ValueError("No position to close in "+str(stock.name))

		self.money += num*price

	def get_equity(self, i):
		res = self.money
		for trade in self.open_trades:
			res += trade.get_equity(i)
		return res

	def next(self, i):
		pass

class Computer:
	def __init__(self, simulations=1, price_sigma=0.02, volume_sigma=0.1):
		"""
		simulations: number of simulated variations to run for each candlestick (n)
		price_sigma: standard deviation (as fraction) for price perturbation (default 2%)
		volume_sigma: standard deviation (as fraction) for volume perturbation (default 10%)
		"""
		self.stocks = []
		self.strategies = []
		self.simulations = max(1, int(simulations))
		self.price_sigma = price_sigma
		self.volume_sigma = volume_sigma

	def add_stock(self, stock):
		if not isinstance(stock, Stock):
			exit("ERR: called 'add_stock' on type: "+str(type(stock)))
		self.stocks.append(stock)
	
	def add_strategy(self, strategy):
		if not isinstance(strategy, Strategy):
			exit("ERR: called 'add_strategy' on type: "+str(type(strategy)))
		self.strategies.append(strategy)

	def run(self):
		import random

		# put stocks in strategies
		for strategy in self.strategies:
			j = 1
			for stock in self.stocks:
				strategy.stocks = [stock]
				print(f"stock #{j}/{len(self.stocks)}")
				j += 1

				# run every day on the strategies
				for i in range(len(stock)):
					# locate the row by label to avoid SettingWithCopy issues
					idx = stock.data.index[i]
					# copy the original row so we can restore it after simulations
					original_row = stock.data.loc[idx].copy()

					# determine which fields we can simulate
					has_high = 'high' in stock.data.columns
					has_low = 'low' in stock.data.columns
					has_close = 'close' in stock.data.columns
					has_volume = 'volume' in stock.data.columns

					# Get original price/volume values (fallbacks if missing)
					orig_open = stock.data.loc[idx]['open'] if 'open' in stock.data.columns else None
					orig_high = stock.data.loc[idx]['high'] if has_high else None
					orig_low = stock.data.loc[idx]['low'] if has_low else None
					orig_close = stock.data.loc[idx]['close'] if has_close else None
					orig_volume = stock.data.loc[idx]['volume'] if has_volume else None

					# Run simulations: mutate the candlestick, run strategy.next(i) and analyzers,
					# repeat for the configured number of simulations.
					for s in range(self.simulations):
						# Start with the original values as a base for perturbation
						new_open = orig_open
						new_close = orig_close
						new_high = orig_high
						new_low = orig_low
						new_volume = orig_volume

						# Perturb prices using gaussian noise proportional to price_sigma
						if has_close and orig_close is not None:
							pert = random.gauss(0, self.price_sigma)
							new_close = orig_close * (1.0 + pert)

						if has_high and orig_high is not None:
							pert = random.gauss(0, self.price_sigma)
							new_high = orig_high * (1.0 + pert)

						if has_low and orig_low is not None:
							pert = random.gauss(0, self.price_sigma)
							new_low = orig_low * (1.0 + pert)

						# Ensure high/low make sense relative to open/close
						# Use available values to enforce consistency
						values_for_bounds = [v for v in [new_open, new_close] if v is not None]
						if values_for_bounds:
							vc_max = max(values_for_bounds)
							vc_min = min(values_for_bounds)
							if new_high is None or new_high < vc_max:
								new_high = vc_max * (1.0 + abs(random.gauss(0, self.price_sigma/2)))
							if new_low is None or new_low > vc_min:
								new_low = vc_min * (1.0 - abs(random.gauss(0, self.price_sigma/2)))

						# Guarantee high >= low
						if new_high is not None and new_low is not None and new_high < new_low:
							# swap or adjust
							avg = (new_high + new_low) / 2.0
							new_high = max(new_high, avg)
							new_low = min(new_low, avg)

						# Perturb volume (keep non-negative integer)
						if has_volume and orig_volume is not None:
							pert = random.gauss(0, self.volume_sigma)
							new_volume = int(max(0, orig_volume * (1.0 + pert)))

						# Write mutated values into the dataframe for this candlestick
						# (only for fields that exist)
						if has_close and new_close is not None:
							stock.data.at[idx, 'close'] = new_close
						if has_high and new_high is not None:
							stock.data.at[idx, 'high'] = new_high
						if has_low and new_low is not None:
							stock.data.at[idx, 'low'] = new_low
						if has_volume and new_volume is not None:
							stock.data.at[idx, 'volume'] = new_volume

						# Set index attr and run strategy + analyzers for this simulated candlestick
						strategy.set_attr("i", i)
						strategy.next(i)

						for analyzer in strategy.analyzers:
							analyzer.next(i)

					# After all simulations, restore the original (final) values into the dataframe
					# so that the "final" candlestick equals the original pre-simulation candlestick.
					# We restore the entire original row to be safe.
					stock.data.loc[idx] = original_row

					# close any open trades on the end of the last day
					if i == len(stock)-1:
						for strat in self.strategies:
							while len(strat.open_trades) > 0:
								trade = strat.open_trades[0]
								strat.sell(trade.stock, trade.num, trade.stock.get(i)["close"])

		# get rid of strategies
		for strategy in self.strategies:
			strategy.stocks = []