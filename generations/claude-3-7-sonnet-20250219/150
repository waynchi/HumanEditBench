plik = open("dane_obrazki.txt")
maxbitybledne = 0
bityBledne = list()
def czyPoprawny(obrazek): # 图像包含字符串列表，可以使用位运算符
                            # 图像[i][j]
    for wiersz in obrazek[:-1]: # 不计算最后一行，那是奇偶校验位
        if wiersz[:-1].count('1') % 2 != int(wiersz[-1]):
            return False
    for i in range(20): # i = 0,1,2,3,4,5,6,7..19
        kolumna = ""
        for j in range(21):  # j = 0,1,2,3,4,5,..20
            kolumna+=obrazek[j][i]
        if kolumna[:-1].count('1')% 2 != int(kolumna[-1]):
            return False
    return True

def czyNaprawialny(obrazek):
    bityKolBleden = 0
    bityWierBledne = 0
    for wiersz in obrazek[:-1]: # 不计算最后一行，那是校验位
        if wiersz[:-1].count('1') % 2 != int(wiersz[-1]):
            bityWierBledne+=1
    for i in range(20): # i = 0,1,2,3,4,5,6,7..19
        kolumna = ""
        for j in range(21):  # j = 0,1,2,3,4,5,..20
            kolumna+=obrazek[j][i]
        if kolumna[:-1].count('1')% 2 != int(kolumna[-1]):
           bityKolBleden+=1
    global maxbitybledne
    if maxbitybledne<(bityKolBleden+bityWierBledne):
        maxbitybledne = bityKolBleden+bityWierBledne
    bityBledne.append(bityKolBleden+bityWierBledne)

    if bityWierBledne >1 :
        return False
    if bityKolBleden > 1:
        return False

    return True

def napraw(obrazek):
    """输入是一个文本文件，其中包含编码为像素的黑白图像数据。0 - 白色像素 1 - 黑色像素。每行和每列的末尾都有一个奇偶校验位。如果行（或列）的1的数量是偶数，则奇偶校验位为0；如果是奇数，则为1。例如：0 1 1 0 1 1 错误的位需要更改为相反的1 1 1 0 1 0 1 1 1 1 1 1 0 1 1 0 0 0 1 1 0 1 1 0 1 1 0 0 0 - 列的奇偶校验位 ^ |- 行的奇偶校验位编写一个函数来查找损坏的图像并修复它们。即这是一个可修复的图像（最多只有一个行的奇偶校验位和一个列的奇偶校验位不正确），然后修复这些图像结果应包含错误的（可修复的）图像和修复后的图像。"""
    wynik = list()
    
    # 复制原始图像
    naprawiony = [row for row in obrazek]
    
    # 查找错误的行和列
    bledny_wiersz = -1
    bledna_kolumna = -1
    
    # 检查行
    for i in range(20):  # 检查前20行（不包括校验行）
        if obrazek[i][:-1].count('1') % 2 != int(obrazek[i][-1]):
            bledny_wiersz = i
            break
    
    # 检查列
    for j in range(20):  # 检查前20列（不包括校验列）
        kolumna = ""
        for i in range(21):
            kolumna += obrazek[i][j]
        if kolumna[:-1].count('1') % 2 != int(kolumna[-1]):
            bledna_kolumna = j
            break
    
    # 如果只有校验位错误
    if bledny_wiersz == -1 and bledna_kolumna == -1:
        # 检查行校验位（最后一行）
        for j in range(20):
            kolumna = ""
            for i in range(20):  # 不包括校验行
                kolumna += obrazek[i][j]
            oczekiwany_bit = '1' if kolumna.count('1') % 2 else '0'
            if oczekiwany_bit != obrazek[20][j]:
                nowy_wiersz = list(naprawiony[20])
                nowy_wiersz[j] = '1' if nowy_wiersz[j] == '0' else '0'
                naprawiony[20] = ''.join(nowy_wiersz)
        
        # 检查列校验位（最后一列）
        for i in range(20):
            wiersz = obrazek[i][:-1]
            oczekiwany_bit = '1' if wiersz.count('1') % 2 else '0'
            if oczekiwany_bit != obrazek[i][-1]:
                nowy_wiersz = list(naprawiony[i])
                nowy_wiersz[-1] = '1' if nowy_wiersz[-1] == '0' else '0'
                naprawiony[i] = ''.join(nowy_wiersz)
    
    # 如果找到了错误的行和列交叉点
    elif bledny_wiersz != -1 and bledna_kolumna != -1:
        # 修改交叉点上的像素
        nowy_wiersz = list(naprawiony[bledny_wiersz])
        nowy_wiersz[bledna_kolumna] = '1' if nowy_wiersz[bledna_kolumna] == '0' else '0'
        naprawiony[bledny_wiersz] = ''.join(nowy_wiersz)
    
    # 如果只有行错误，需要修复行校验位
    elif bledny_wiersz != -1 and bledna_kolumna == -1:
        nowy_wiersz = list(naprawiony[bledny_wiersz])
        nowy_wiersz[-1] = '1' if nowy_wiersz[-1] == '0' else '0'
        naprawiony[bledny_wiersz] = ''.join(nowy_wiersz)
    
    # 如果只有列错误，需要修复列校验位
    elif bledny_wiersz == -1 and bledna_kolumna != -1:
        nowy_wiersz = list(naprawiony[20])
        nowy_wiersz[bledna_kolumna] = '1' if nowy_wiersz[bledna_kolumna] == '0' else '0'
        naprawiony[20] = ''.join(nowy_wiersz)
    
    wynik.append(obrazek)
    wynik.append(naprawiony)
    return wynik

poprawne = 0
naprawialne = 0
obrazek = list()
for linia in plik:
    wiersz = linia.strip() # 去掉空白字符，例如回车
   # wiersz = wiersz[:-1]  # 仅包含图像数据，不包括奇偶校验位，现在读取整行数据
    obrazek.append(wiersz)
    if len(obrazek) == 21: # 我们有21行，即整个图像连同奇偶校验位行一起
        if czyPoprawny(obrazek):
            poprawne+=1
        elif czyNaprawialny(obrazek):
            naprawialne+=1
            naprawiony = napraw(obrazek)


    if len(obrazek) == 22:  # 在第22行之后清理图像以读取下一个图像的行
        obrazek = list()

print(poprawne,naprawialne,200-poprawne-naprawialne)
print(maxbitybledne,max(bityBledne))