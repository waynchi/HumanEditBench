import requests # 用于API请求
import xml.etree.ElementTree # 用于处理 API 的 xml 响应
import matplotlib.pyplot as plt # 用于绘制图表
import pandas as pd # 用于创建数据框并将所有蜡烛分为两种类型：收盘和开盘
import datetime # 用于x轴的日期
import pickle # 用于在文件中存储变量
import json
import aiohttp
import aiofiles
import asyncio


# "货币类"
class valute():
    """货币及其相关内容，通过俄罗斯央行

所需库：

requests

xml.etree.ElementTree

matplotlib.pyplot as plt

pandas as pd

datetime

pickle

json

aiohttp

aiofiles

asyncio"""
    def __init__(self, name):
        self.name = name
        
    async def correct_name(self):
        """检查货币名称是否存在于货币集合中。集合每天更新不超过一次。"""
        async with aiofiles.open(r"D:\MoexAPI_bot_aiogram3\data_files\Info.json", "r", encoding="utf-8") as info_opened_file: # 打开信息文件，使用编码以避免问题
            info = json.loads(await info_opened_file.read())
            
        if datetime.datetime.now() - datetime.timedelta(days=1) > datetime.datetime.strptime(info["last_day_check"]["valute"], "%Y-%m-%d %H:%M:%S.%f"): # 检查条件，确保货币列表的重写日期至少是1天前。
            # 如果相差超过1天，则重写货币列表（集合）：
            set_valutes = set() # 创建一个空集合，用于存储货币
            s = "http://www.cbr.ru/scripts/XML_daily.asp"
            async with aiohttp.ClientSession() as session:
                async with session.get(s) as response:
                    content = await response.text()
                    root = xml.etree.ElementTree.fromstring(content) # 请求仍然会将网站数据作为字符串返回，所以必须使用fromstring。
                    for Valute in root.findall("Valute"):
                        CharCode = Valute.find("CharCode")
                        set_valutes.add(CharCode.text) # 将货币注入我们的集合中
                        
            async with aiofiles.open(r"D:\MoexAPI_bot_aiogram3\data_files\set_valutes.bin", "wb") as set_valutes_file_opened: # 打开文件以二进制方式写入集合中的代码标识符
                await set_valutes_file_opened.write(pickle.dumps(set_valutes)) # 将创建的集合写入文件。如果有变化，每次都会重写（已验证）
            
            # 更改最后更新时间
            info["last_day_check"]["valute"] = str(datetime.datetime.now())
            async with aiofiles.open(r"D:\MoexAPI_bot_aiogram3\data_files\Info.json", "w", encoding="utf-8") as info_opened_file:
                await info_opened_file.write(json.dumps(info, indent=3, ensure_ascii=False)) # 写入新文件
                
        # 现在只需检查货币是否在货币列表中
        async with aiofiles.open(r"D:\MoexAPI_bot_aiogram3\data_files\set_valutes.bin", "rb") as set_valutes_file_opened: # 打开包含多个代码的文件以从中获取它
            set_valutes = pickle.loads(await set_valutes_file_opened.read()) # 从打开的文件中将货币集合的值加载到变量中。如果意外地记录了多个集合（不应该发生这种情况），则只会打开其中的第一个。
            
        if self.name in set_valutes: # 只需检查货币是否在代码集中
            return True
        else:
            return False
            
    async def CurrentExchangeRate(self):
        '''当前货币兑换卢布的汇率'''
        async with aiohttp.ClientSession() as session:
            async with session.get("http://www.cbr.ru/scripts/XML_daily.asp") as response: # 俄罗斯央行 API
                content = await response.text()
                root = xml.etree.ElementTree.fromstring(content)
                
                for Valute in root.findall("Valute"): # 寻找货币容器
                    for CharCode in Valute.findall("CharCode"): # 寻找字符代码的容器
                        if CharCode.text == self.name: # 找到所需货币的容器
                            return (Valute.find("VunitRate").text)