function createTurnState(allyStates, foeStates) {
  // Encontrar el turno actual basado en qué grupo todavía tiene unidades que pueden actuar
  let currentTurn = determineCurrentTurn(allyStates, foeStates);

  function determineCurrentTurn(allies, foes) {
    // Si hay unidades aliadas que aún no han actuado, es turno del jugador
    const alliesCanAct = allies.some(unit => !unit.hasActed);
    // Si hay unidades enemigas que aún no han actuado, es turno de la CPU
    const foesCanAct = foes.some(unit => !unit.hasActed);
    
    // Por defecto, comienza con el turno del jugador
    if (alliesCanAct) {
      return "player";
    } else if (foesCanAct) {
      return "cpu";
    } else {
      // Si todas las unidades ya han actuado, reiniciamos al turno del jugador
      return "player";
    }
  }

  let turnNumber = 1;

  function getCurrentTurn() {
    return currentTurn;
  }

  function getTurnNumber() {
    return turnNumber;
  }

  function nextTurn() {
    if (currentTurn === "player") {
      currentTurn = "cpu";
      // Lógica de la CPU aquí (por ejemplo, movimiento y acciones de IA)
      allyStates.forEach(unit => unit.hasActed = true);
      foeStates.forEach(unit => unit.hasActed = false);
      cpuTurn();
    } else {
      currentTurn = "player";
      foeStates.forEach(unit => unit.hasActed = true);
      allyStates.forEach(unit => unit.hasActed = false);
      turnNumber++; // Incremente el número de turno solo después del turno del jugador
    }
     // Restablecer la disponibilidad de acción para todas las unidades al inicio de un nuevo turno
  }

  function cpuTurn() {
    // Ejemplo de comportamiento de la CPU (reemplazar con tu lógica de IA real)
    for (const cpuUnit of foeStates) {
      if (!cpuUnit.hasActed) { // Verificar si la unidad ya ha actuado en este turno
        // Realizar acciones de la CPU (por ejemplo, movimiento, ataque)
        // ... tu lógica de IA de CPU aquí ...

        cpuUnit.hasActed = true; // Marcar la unidad como que ha actuado
      }
    }

    // Después de que todas las unidades de la CPU hayan actuado (o decidido no hacerlo), termina el turno de la CPU
    nextTurn(); // Cambiar automáticamente de nuevo al turno del jugador
  }  

  return {
    getCurrentTurn,
    getTurnNumber,
    nextTurn
  };
}

export { createTurnState };