def is_sum_of_four_squares(n):
    """
    Check if a number can be expressed as the sum of four non-zero squares.
    Uses Jacobi's four-square theorem and checks for valid decompositions.
    """
    if n <= 0:
        return False
    
    # Check all possible combinations of four non-zero squares
    # We only need to check up to sqrt(n/4) for the first square
    # since we need at least 3 more non-zero squares (minimum 1^2 each)
    max_val = int((n // 4) ** 0.5) + 1
    
    for a in range(1, max_val + 1):
        a_sq = a * a
        if a_sq >= n:
            break
            
        remaining1 = n - a_sq
        max_b = int((remaining1 // 3) ** 0.5) + 1
        
        for b in range(1, max_b + 1):
            b_sq = b * b
            if a_sq + b_sq >= n:
                break
                
            remaining2 = remaining1 - b_sq
            max_c = int((remaining2 // 2) ** 0.5) + 1
            
            for c in range(1, max_c + 1):
                c_sq = c * c
                if a_sq + b_sq + c_sq >= n:
                    break
                    
                remaining3 = remaining2 - c_sq
                d = int(remaining3 ** 0.5)
                
                if d > 0 and d * d == remaining3:
                    return True
    
    return False

def find_sum_of_four_squares(n):
    """
    Find the actual decomposition of n as sum of four non-zero squares.
    Returns a tuple (a, b, c, d) such that a^2 + b^2 + c^2 + d^2 = n
    """
    if n <= 0:
        return None
    
    max_val = int((n // 4) ** 0.5) + 1
    
    for a in range(1, max_val + 1):
        a_sq = a * a
        if a_sq >= n:
            break
            
        remaining1 = n - a_sq
        max_b = int((remaining1 // 3) ** 0.5) + 1
        
        for b in range(1, max_b + 1):
            b_sq = b * b
            if a_sq + b_sq >= n:
                break
                
            remaining2 = remaining1 - b_sq
            max_c = int((remaining2 // 2) ** 0.5) + 1
            
            for c in range(1, max_c + 1):
                c_sq = c * c
                if a_sq + b_sq + c_sq >= n:
                    break
                    
                remaining3 = remaining2 - c_sq
                d = int(remaining3 ** 0.5)
                
                if d > 0 and d * d == remaining3:
                    return (a, b, c, d)
    
    return None

# Example usage and testing
if __name__ == "__main__":
    # Test some numbers
    test_numbers = [4, 10, 15, 20, 30, 50, 100]
    
    for num in test_numbers:
        if is_sum_of_four_squares(num):
            decomposition = find_sum_of_four_squares(num)
            a, b, c, d = decomposition
            print(f"{num} = {a}² + {b}² + {c}² + {d}² = {a*a} + {b*b} + {c*c} + {d*d}")
        else:
            print(f"{num} cannot be expressed as sum of four non-zero squares")