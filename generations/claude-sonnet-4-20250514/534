import xml.etree.ElementTree # para procesar la respuesta xml de la API
import matplotlib.pyplot as plt # para la construcción de gráficos
import pandas as pd # para crear un dataframe y dividir todas las velas en dos tipos: close y open
import datetime # para las fechas en el eje x
import pickle # para almacenar variables en un archivo
import json # para trabajar con la base de datos
import aiofiles # trabajo asincrónico con archivos
import requests # solicitudes http síncronas
from typing import List
from matplotlib.axes import Axes # para facilitar la visualización


# estableceremos el diccionario estándar de análisis técnico. Lo usaremos para analizar las solicitudes de callback en el enrutador de construcción de gráficos (ya que allí es incómodo obtener tick_inp)
standart_tech_dict = {"value" : {"use" : False, "has_periods" : False, "need_graph_space" : True}, 
                          "sma" : {"use" : False, "has_periods" : True, "periods" : [], "need_graph_space" : False},
                          "ema" : {"use" : False, "has_periods" : True, "periods" : [],"need_graph_space" : False}
                        }

# no hay problemas con las herramientas de análisis técnico y los días vacíos (sin operaciones), ya que los días sin operaciones en el dataframe no son ceros, simplemente no existen. Por lo tanto, no afectan los valores de los indicadores
# clase ticker, métodos gráfico y precio actual
class ticker():
    """Ticker de acciones y todo lo relacionado con él, a través de MoexApi"""
    def __init__(self, name: str):
        """self.name - nombre del ticker self.tech_dict - diccionario de análisis técnico"""
        self.name = name 
        """Имя тикера, то есть сам по себе тикер"""
        # en principio aquí se pueden cambiar las configuraciones predeterminadas comunes para todos los usuarios. Potencialmente se necesita implementar herramientas de análisis técnico personalizadas a través de esto
        self.tech_dict = standart_tech_dict
        """Словарь реализованных опций теханализа. Имеет вид \n
        {"sma": {"use": True, "periods": [20, 50], "need_graph_space": False}, "rsi": {"use": True, "periods": [10], "need_graph_space": True}} \n
        Где use отвечает за использование, period - список периодов, по которым будут считаться значения, need_graph_space за то, требует ли осциллятор доп места на графике \n
        Изначально все use имеют значение False, а списки периодов пусты \n \n
        При реализации нового инструмента теханализа достаточно дописать его в self.tech_dict \n
        При этом функцию, соответствующую этому инструменту важно назвать также, как и сам инструмент в словаре. А её аргументы - self и ax (редактируемый/заполняемый график) \n
        Доп графики инструментов теханализа, которые их требуют, будут отображаться в таком же порядке, в котором инструменты располагаются в словаре. Также в этом порядке будут высвечиваться кнопки в боте и уже выбранные инструменты теханализа"""
    async def correct_name(self):
        """Verificación del nombre del ticker en el conjunto de tickers. El conjunto se actualiza no más de una vez al día"""
        async with aiofiles.open(r"D:\MoexAPI_bot_aiogram3\data_files\Info.json", "r", encoding="utf-8") as info_opened_file:
            info = json.loads(await info_opened_file.read())
        if datetime.datetime.now() - datetime.timedelta(days=1) > datetime.datetime.strptime(info["last_day_check"]["ticker"], "%Y-%m-%d %H:%M:%S.%f"): # comprobamos la condición de que la fecha de reescritura de la lista de tickers sea al menos de hace 1 día
            # si difiere en más de 1 día, entonces reescribimos la lista (conjunto) de tickers:
            set_tickers = set() # creamos un conjunto vacío, en él vamos a verter los tickers
            s = "https://iss.moex.com/iss/engines/stock/markets/shares/boards/TQBR/securities.xml?iss.meta=off"
            response = requests.get(s)
            root = xml.etree.ElementTree.fromstring(response.text)
            for data in root.findall("data"):
                if data.get("id") == "securities":
                    rows = data.find("rows")
                    for row in rows.findall("row"):
                        set_tickers.add(row.get("SECID")) # llenamos los tickers en nuestro conjunto
            async with aiofiles.open(r"D:\MoexAPI_bot_aiogram3\data_files\set_tickers.bin", "wb") as set_tickers_file_opened: # abrimos el archivo para escritura binaria del conjunto de tickers en él
                await set_tickers_file_opened.write(pickle.dumps(set_tickers)) # guardamos el conjunto creado en el archivo. Si acaso, se sobrescribirá cada vez (comprobado)
            # cambiamos el tiempo de la última actualización
            info["last_day_check"]["ticker"] = str(datetime.datetime.now())
            async with aiofiles.open(r"D:\MoexAPI_bot_aiogram3\data_files\Info.json", "w", encoding="utf-8") as info_opened_file:
                await info_opened_file.write(json.dumps(info, indent = 3, ensure_ascii = False)) # escribiremos un nuevo archivo
        # ahora simplemente verificamos si el ticker está en la lista de tickers
        async with aiofiles.open(r"D:\MoexAPI_bot_aiogram3\data_files\set_tickers.bin", "rb") as set_tickers_file_opened: # abrimos el archivo con múltiples tickers para obtenerlo de allí
            set_tickers = pickle.loads(await set_tickers_file_opened.read()) # del archivo abierto descargamos el valor del conjunto de tickers en una variable. Si por alguna razón se escriben varios conjuntos (lo cual no debería suceder), solo se abrirá el primero de ellos
        if self.name in set_tickers: # simplemente verificamos si el ticker está en el conjunto de tickers
            return True
        else:
            return False
    async def CurrentPrice(self):
        """Precio actual para este ticker"""
        s = "https://iss.moex.com/iss/engines/stock/markets/shares/boards/TQBR/securities/" + self.name + ".xml?iss.meta=off"
        response = requests.get(s)
        root = xml.etree.ElementTree.fromstring(response.text)
        for data in root.findall("data"): # dentro de root encontramos todos los contenedores data y los recorremos
            if data.get("id") == "marketdata": # Dentro de data por el que pasamos, miramos el atributo id y queremos que sea marketdata
                rows = data.find("rows") # dentro de rows encontramos el primer contenedor con la etiqueta row
                row = rows.find("row") # dentro de rows hay varios row
                return(row.get("LAST")) # return romperá los ciclos, por lo tanto, aquí no se necesitan verificaciones de si se encontró la información
    async def candles(self, candles_name: str, timeframe: str, start: str, end: str):
        """Lista de velas para este ticker

candles_name - componente necesario de las velas

candles_name: open, close, high, low, value, volume, begin, end

timeframe - marco de tiempo: 1 - 1 min, 10 - 10 min, 60 - 1h, 24 - 1d, 7 - 1s, 31 - 1mes, 4 - 4meses

start, end - inicio y fin del período, formato AAAA-MM-DD HH:MM:SS"""
        s = "https://iss.moex.com/iss/engines/stock/markets/shares/boards/TQBR/securities/" + self.name + f"/candles.xml?iss.meta=off&interval={timeframe}&till={end}&from={start}"
        response = requests.get(s)
        root = xml.etree.ElementTree.fromstring(response.text)
        candles = root.find("data")
        rows = candles.find("rows")
        listcandles = []
        if candles_name == "begin" or candles_name == "end": # para estos tomaremos valores de iss en formato datetime del módulo conectado (fecha y hora)
            for row in rows.findall("row"):
                datetime_str = row.get(candles_name) # datetime_name ahora es una cadena en formato api
                # se podría usar datetime.datetime.strptime(), pero no es genial con los años, no es universal. Por eso así
                datetime_datetime = datetime.datetime(int(datetime_str[0:4]), int(datetime_str[5:7]), int(datetime_str[8:10]), int(datetime_str[11:13]), int(datetime_str[14:16]), int(datetime_str[17:])) # dividimos la cadena con la fecha y hora en partes de fecha y partes de tiempo necesarias para el módulo datetime (año, mes, día, hora, minuto, segundo). No olvidamos convertir todo a int
                listcandles.append(datetime_datetime)
        else:
            for row in rows.findall("row"):
                listcandles.append(float(row.get(candles_name)))# ES IMPORTANTE FLOAT, ya que de lo contrario se importa como cadena,
                # y el gráfico construye las cadenas simplemente una tras otra, sin una disposición adecuada de los valores según sus valores
        return(listcandles)
    def setattr_candles_dataframe(self, timeframe = str("24"), start = str(""), end = str("")):
        # crear un dataframe de velas como atributo al menos permite no pasarlo cada vez como argumento de la función que aplica la herramienta de análisis técnico (ya que se pasa en self)
        """Crea un dataframe de velas con el timeframe, start y end correspondientes y lo coloca en self.candles_dataframe

No al iniciar, ya que si el ticker se inicia para obtener el precio actual, no hay razones para realizar operaciones innecesarias."""
        # Creamos un dataframe con toda la información de las velas y lo llenamos usando el método previamente escrito para obtener información de las velas.
        candles_dataframe = pd.DataFrame({"open" :  self.candles("open", timeframe, start, end),
                                          "close" : self.candles("close", timeframe, start, end),
                                          "high" : self.candles("high", timeframe, start, end),
                                          "low" : self.candles("low", timeframe, start, end),
                                          "value" : self.candles("value", timeframe, start, end),
                                          "begin" : self.candles("begin", timeframe, start, end)
                                          # end" parece no ser necesario, begin es suficiente
                                        })
        setattr(self, "candles_dataframe", candles_dataframe)
    def graphic(self, timeframe = str("24"), start = str(""), end = str(""), user_id = int(1124123332)):
        """Devuelve el gráfico de velas de precios abierto desde el tiempo

timeframe - marco de tiempo: 1 - 1 min, 10 - 10 min, 60 - 1h, 24 - 1d, 7 - 1s, 31 - 1mes, 4 - 4meses | None = 24

start, end - inicio y fin del período, formato AAAA-MM-DD HH:MM:SS | None = ""

user_id - id del usuario para el cual es este archivo. Será parte del nombre del archivo

Agrega todas las herramientas necesarias de análisis técnico, basándose en self.tech_dict"""
        # crearemos el dataframe necesario
        self.setattr_candles_dataframe(timeframe, start, end)
        # hacemos up y down - nuevos dataframes, partes del antiguo, pero que satisfacen ciertas condiciones
        up = self.candles_dataframe[self.candles_dataframe.close >= self.candles_dataframe.open]
        down = self.candles_dataframe[self.candles_dataframe.close < self.candles_dataframe.open]
        # Guardamos esto como atributos, ya que para algunos instrumentos de análisis técnico es importante cuáles velas suben y cuáles bajan.
        setattr(self, "up", up)
        setattr(self, "down", down)
        # crearemos width_big y width_small - anchos de velas que dependen del marco de tiempo
        # al parecer 1 día en el eje x corresponde a 1 unidad de grosor de la barra en el diagrama (probablemente Python es inteligente)
        # aunque en 4 meses ya no funciona, aunque es extraño, porque para todos los demás funciona
        # pero en cualquier caso, al aumentar o disminuir el rango, las velas no comienzan a superponerse/tener grandes espacios. Así que el ancho está relacionado precisamente con las fechas
        if timeframe == "1": # minuto
            width_big = 1/24/60
        elif timeframe == "10": # 10 minutos
            width_big = 1/24/6
        elif timeframe == "60": # hora
            width_big = 1/24
        elif timeframe == "24": # día
            width_big = 1
        elif timeframe == "7": # semana
            width_big = 7
        elif timeframe == "31": # mes
            width_big = 30
        elif timeframe == "4": # 4 meses
            width_big = 90
        else:
            width_big = 0 # en teoría esto no puede suceder
        width_small = width_big/10
        setattr(self, "width_big", width_big) # colocaremos width_big en self, para luego usarlo en herramientas de análisis técnico que se representan como gráfico de barras
        setattr(self, "width_small", width_small) # Insertamos width_big en self para luego usarlo en herramientas de análisis técnico que se representan como gráficos de barras.
        # nos ocuparemos del análisis técnico. Para empezar, entenderemos cuántos gráficos adicionales se necesitan para ellos
        number_of_additional_graphics = int(0)
        for tech in self.tech_dict:
            if self.tech_dict[tech]["use"] and self.tech_dict[tech]["need_graph_space"]: # si se utiliza la herramienta de análisis técnico Y si esta herramienta de análisis técnico necesita espacio para un gráfico adicional, lo contamos
                number_of_additional_graphics += 1
        # si 1 o más herramientas de análisis técnico quieren un gráfico adicional
        if number_of_additional_graphics != 0:
            height_rations_list = [10 - number_of_additional_graphics] + [1] * number_of_additional_graphics # array de relaciones de alturas de gráficos, dependiendo del número de gráficos. Luego lo pasaremos a subplots. Tiene la forma [8, 1, 1]
            fig, axs = plt.subplots(nrows = 1 + number_of_additional_graphics, ncols = 1, sharex = True, height_ratios = height_rations_list) # creamos subplots. fig - contenedor de gráficos, axs[i] - i-ésimo gráfico
            axs: List[Axes] # para sugerencias en PyCharm
            plt.suptitle(self.name, fontsize = 15) # título - nombre del ticker
            axs[0].grid(True) # rejilla para simplificar la percepción del gráfico
            # llenamos con velas up
            # es un diagrama de barras; plt.bar(x = eje x, height = altura de la barra, width = ancho de la barra, bottom = coordenada inferior de la barra, no sé más, extraño * y luego algo más incomprensible)
            # también hay un argumento color, pero en la documentación oficial no lo encontré. Posiblemente esto esté incluido en la extraña *
            axs[0].bar(x = up.begin, height = up.close - up.open,  width = width_big, bottom = up.open, color = "green") # para especificar qué argumento de función estamos escribiendo, se puede escribir nombre_argumento = valor_que_damos
            axs[0].bar(x = up.begin, height = up.high - up.close,  width = width_small, bottom = up.close, color = "green")
            axs[0].bar(x = up.begin, height = up.open - up.low,  width = width_small, bottom = up.low, color = "green")
            # rellenamos con velas down
            axs[0].bar(x = down.begin, height = down.open - down.close,  width = width_big, bottom = down.close, color = "red")
            axs[0].bar(x = down.begin, height = down.high - down.open,  width = width_small, bottom = down.open, color = "red")
            axs[0].bar(x = down.begin, height = down.close - down.low,  width = width_small, bottom = down.low, color = "red")
            # agregamos herramientas de análisis técnico al gráfico
            for tech in self.tech_dict:
                if self.tech_dict[tech]["use"]: # si se utiliza la herramienta de análisis técnico
                    if self.tech_dict[tech]["use"] and not self.tech_dict[tech]["need_graph_space"]: # si no requiere un gráfico adicional, llamaremos a la función correspondiente
                        tech_func = getattr(self, tech) # ahora tech_func es la función de ese análisis técnico, cuyo nombre actualmente lleva tech
                        tech_func(axs[0])
                    else : # si requiere gráfico adicional, entonces
                        for i in range(number_of_additional_graphics):
                            tech_func = getattr(self, tech) # ahora tech es el nombre de la función que requiere un gráfico adicional
                            axs[i + 1].grid(True) # activamos la cuadrícula también en cada gráfico adicional
                            tech_func(axs[i + 1]) # para cada nuevo instrumento usamos un nuevo gráfico
        # si 0 herramientas de análisis técnico requieren un gráfico adicional
        else: 
            fig = plt.figure() # creamos un contenedor de gráficos
            plt.title(self.name, fontsize = 15) # título - nombre del ticker
            ax = fig.add_subplot() # ax - es el propio gráfico (los ejes de este gráfico, pero no como ejes en el sentido de muchos ejes, sino como ejes en el sentido de gráfico definido por ejes)
            ax.grid(True) # Cuadrícula para simplificar la percepción del gráfico
            # lo llenamos con velas up
            # es un diagrama de barras; plt.bar(x = eje x, height = altura de la barra, width = ancho de la barra, bottom = coordenada inferior de la barra, no sé más, extraño * y luego algo más que no entiendo)
            # También hay un argumento color, pero no lo encontré en la documentación oficial. Posiblemente esto esté incluido en la extraña *
            ax.bar(x = up.begin, height = up.close - up.open,  width = width_big, bottom = up.open, color = "green") # para especificar qué argumento de la función estamos escribiendo, se puede escribir nombre_argumento = valor_que_damos
            ax.bar(x = up.begin, height = up.high - up.close,  width = width_small, bottom = up.close, color = "green")
            ax.bar(x = up.begin, height = up.open - up.low,  width = width_small, bottom = up.low, color = "green")
            # rellenamos con velas down
            ax.bar(x = down.begin, height = down.open - down.close,  width = width_big, bottom = down.close, color = "red")
            ax.bar(x = down.begin, height = down.high - down.open,  width = width_small, bottom = down.open, color = "red")
            ax.bar(x = down.begin, height = down.close - down.low,  width = width_small, bottom = down.low, color = "red")
            # agregamos al gráfico herramientas de análisis técnico que no requieren un gráfico adicional (en esta sección son todas las herramientas utilizadas, ya que antes había una condición de que no hay herramientas con gráfico adicional)
            for tech in self.tech_dict:
                if self.tech_dict[tech]["use"]: # si se utiliza y no requiere gráfico adicional, llamaremos a la función correspondiente
                    tech_func = getattr(self, tech) # ahora tech_func es la función de ese análisis técnico, cuyo nombre actualmente lleva tech, y está vinculada a self. En otras palabras, su aplicación es similar a aplicar self.sma(...) cuando tech = sma
                    tech_func(ax)

        # guardamos el gráfico como una imagen en el búfer io.BytesIO y devolvemos este búfer
        fig.savefig(r"D:\MoexAPI_bot_aiogram3\data_files\graph_for_" + str(user_id) + ".png")
        plt.close(fig) # finalizar el trabajo de plt con esta fig
        return True # simplemente devolveremos True cuando todo haya salido bien
    
    # descripciones de funciones de análisis técnico.
    # Cada una tiene como argumentos self para usar atributos y ax, para colocar en este ax la herramienta de análisis técnico (ax - gráfico principal para análisis técnico sin gráficos adicionales y adicional para el análisis técnico que lo necesita)
    # Además, los nombres de las funciones de análisis técnico deben corresponder a los nombres en tech_dict, ya que se utiliza getattr(self, *nombre del instrumento de análisis técnico*) para obtener funciones, y *los nombres de análisis técnico* se toman de tech_dict
    def sma(self, ax):
        for period in self.tech_dict["sma"]["periods"]: # Para cada período necesario de sma, crearemos una lista de valores sma y la añadiremos al gráfico.
            if period <=  len(self.candles_dataframe.begin): # ya que de lo contrario, al construir el gráfico, la lista del eje x está vacía, mientras que el eje y no lo está (porque allí hay una base recurrente)
                sma_list = [] # lista de valores sma (corresponde a las fechas del dataframe)
                sma_list.append(sum(self.candles_dataframe.close[0: period])/period) # Hacemos recurrente, para no calcular cada vez una suma grande
                for i in range(period, len(self.candles_dataframe.begin)): # el inicio se desplaza, ya que el sma no se calcula antes de que haya period velas
                    sma_list.append(sma_list[i - period] + (self.candles_dataframe.close[i] - self.candles_dataframe.close[i - period])/period) # añadimos una nueva vela al valor anterior de sma y eliminamos la más antigua
                ax.plot(self.candles_dataframe.begin[period - 1:], sma_list) # se necesita un recorte en el eje x para que el oscilador comience desde la fecha en que lo calculamos
    def ema(self, ax):
        for period in self.tech_dict["ema"]["periods"]:
            if period <=  len(self.candles_dataframe.begin): # ya que de lo contrario, al construir el gráfico, la lista del eje x está vacía, mientras que el eje y no está vacío (porque allí hay una base recurrente)
                ema_list = []
                ema_list.append(sum(self.candles_dataframe.close[0: period])/period) # el primer valor de ema es el sma para el mismo período
                for i in range(period, len(self.candles_dataframe.begin)):
                    ema_list.append(((period - 1)*ema_list[i - period] + 2 * self.candles_dataframe.close[i])/(period + 1))
                ax.plot(self.candles_dataframe.begin[period - 1:], ema_list)
    def value(self, ax):
        ax.bar(x = self.up.begin, height = self.up.value, width = self.width_big, color = "green")
        ax.bar(x = self.down.begin, height = self.down.value, width = self.width_big, color = "red")
        ax.set_title("Value", fontsize = 7)

"""
Тесты
"""

"""
beb = ticker("SBER")
beb.setattr_candles_dataframe("24", "2024-01-01", "2024-01-07")
print(beb.candles_dataframe)
"""

"""
beb.tech_dict["value"]["use"] = True
beb.graphic("24", "2024-01-01", "2024-10-01")
plt.show
"""

"""
beb = ticker("SBER")
beb.tech_dict["sma"]["use"] = True
beb.tech_dict["sma"]["periods"] = [20, 10]
beb.tech_dict["ema"]["use"] = True
beb.tech_dict["ema"]["periods"] = [150, 250]
beb.tech_dict["value"]["use"] = True
beb.graphic("24", "2024-01-01", "2024-05-01")
"""