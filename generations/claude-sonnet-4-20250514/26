import numpy as np

def conjugate_gradient(A, b, x0=None, tol=1e-6, max_iter=1000):
    """
    Решение системы линейных уравнений Ax = b методом сопряженных градиентов
    
    Parameters:
    A : array_like, shape (n, n)
        Симметричная положительно определенная матрица
    b : array_like, shape (n,)
        Вектор правой части
    x0 : array_like, shape (n,), optional
        Начальное приближение (по умолчанию нулевой вектор)
    tol : float, optional
        Допустимая погрешность (по умолчанию 1e-6)
    max_iter : int, optional
        Максимальное количество итераций (по умолчанию 1000)
    
    Returns:
    x : ndarray, shape (n,)
        Решение системы уравнений
    iterations : int
        Количество выполненных итераций
    """
    
    A = np.array(A)
    b = np.array(b)
    n = len(b)
    
    # Инициализация начального приближения
    if x0 is None:
        x = np.zeros(n)
    else:
        x = np.array(x0)
    
    # Начальный остаток
    r = b - A @ x
    
    # Начальное направление поиска
    p = r.copy()
    
    # Квадрат нормы остатка
    rsold = r @ r
    
    for i in range(max_iter):
        # Произведение матрицы на направление поиска
        Ap = A @ p
        
        # Размер шага вдоль направления поиска
        alpha = rsold / (p @ Ap)
        
        # Обновление решения
        x = x + alpha * p
        
        # Обновление остатка
        r = r - alpha * Ap
        
        # Квадрат нормы нового остатка
        rsnew = r @ r
        
        # Проверка сходимости
        if np.sqrt(rsnew) < tol:
            return x, i + 1
        
        # Коэффициент для нового направления поиска
        beta = rsnew / rsold
        
        # Новое направление поиска
        p = r + beta * p
        
        # Обновление квадрата нормы остатка
        rsold = rsnew
    
    print(f"Предупреждение: Достигнуто максимальное количество итераций ({max_iter})")
    return x, max_iter