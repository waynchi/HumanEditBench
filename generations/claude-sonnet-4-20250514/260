import numpy as np

def conjugate_gradient(A, b, x0=None, tol=1e-6, max_iter=1000):
    """
    Решает систему линейных уравнений Ax = b методом сопряжённых градиентов
    
    Parameters:
    A : array_like
        Симметричная положительно определённая матрица размера n x n
    b : array_like
        Вектор правой части размера n
    x0 : array_like, optional
        Начальное приближение. По умолчанию нулевой вектор
    tol : float, optional
        Допустимая погрешность. По умолчанию 1e-6
    max_iter : int, optional
        Максимальное количество итераций. По умолчанию 1000
    
    Returns:
    x : ndarray
        Решение системы уравнений
    residual_norm : float
        Норма невязки
    iterations : int
        Количество выполненных итераций
    """
    
    A = np.array(A, dtype=float)
    b = np.array(b, dtype=float)
    n = len(b)
    
    # Начальное приближение
    if x0 is None:
        x = np.zeros(n)
    else:
        x = np.array(x0, dtype=float)
    
    # Начальная невязка
    r = b - A @ x
    
    # Начальное направление поиска
    p = r.copy()
    
    # Начальная норма невязки
    rsold = r @ r
    
    for i in range(max_iter):
        # Произведение матрицы на направление поиска
        Ap = A @ p
        
        # Размер шага
        alpha = rsold / (p @ Ap)
        
        # Обновление решения
        x = x + alpha * p
        
        # Обновление невязки
        r = r - alpha * Ap
        
        # Новая норма невязки
        rsnew = r @ r
        
        # Проверка сходимости
        if np.sqrt(rsnew) < tol:
            return x, np.sqrt(rsnew), i + 1
        
        # Коэффициент для обновления направления поиска
        beta = rsnew / rsold
        
        # Новое направление поиска
        p = r + beta * p
        
        # Обновление нормы невязки
        rsold = rsnew
    
    return x, np.sqrt(rsold), max_iter